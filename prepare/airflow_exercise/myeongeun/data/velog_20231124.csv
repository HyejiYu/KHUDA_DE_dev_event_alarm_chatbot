title,writer,img,text,link
Chrome Web Driver 최신 버전 설치 방법 119.**,SYiee.log,https://velog.velcdn.com/images/syiee/post/ee89bdb2-5adf-4952-9359-52393a138816/image.png,"Chrome Web Driver 최신 버전 설치 방법 119.**기타Chrome Web Driver최근 Selenium 을 사용해 웹 크롤링을 하는데 이때 크롬 웹드라이버가 필요했다. 그런데 크롬을 실행할 때마다 자동으로 버전이 업데이트 되면서 새로운 드라이버 버전으로 맞추어 주어야 했다.Chrome 버전 확인하기우측 상단의 ... > 도움말 > Chrome 정보 > 버전 확인하기Chrome Web Driver 설치하기원래는 아래 사이트에서 자신의 웹 버전에 맞는 크롬 웹 드라이버를 설치하면 된다.
https://chromedriver.chromium.org/downloads그러나 사이트 업데이트가 느려서 인지 최신 버전인 119.** 는 사이트에 올라와 있지 않았다.그럴때 아래 방법을 사용하면 최신 버전을 다운로드 할 수 있다.
아래의 깃허브 주소로 들어가 download json파일에서 원하는 버전의 드라이버 다운로드 링크를 확인할 수 있다.https://github.com/GoogleChromeLabs/chrome-for-testing/blob/main/data/latest-versions-per-milestone-with-downloads.json원하는 버전을 찾고 자신의 운영체제에 해당하는 주소를 복사해 url창에 붙여넣으면 자동으로 zip파일이 다운로드 된다.
예를 들어, 119 버전의 win64가 필요하다면 아래 링크를 복사해서 사용하면 된다.
들어가기 귀찮으신 분들을 위해 링크를 남겨둔다.chrome web driver 119 version downloadwin64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.105/win64/chromedriver-win64.zipwin32 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.105/win32/chromedriver-win32.zipmac-x64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.105/mac-x64/chromedriver-mac-x64.ziplinux64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.105/linux64/chromedriver-linux64.zipchrome web driver 120 version downloadwin64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/120.0.6099.28/win64/chromedriver-win64.zipwin32 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/120.0.6099.28/win32/chromedriver-win32.zipmac-x64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/120.0.6099.28/mac-x64/chromedriver-mac-x64.ziplinux64 : https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/120.0.6099.28/linux64/chromedriver-linux64.zipReview of my 2022 & 2023 My New Year Plan",https://velog.io/@syiee/Chrome-Web-Driver-%EC%B5%9C%EC%8B%A0-%EB%B2%84%EC%A0%84-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95-119
프론트엔드도 데이터 설계를 해야 하는 이유 (feat. 백엔드),composite.log,https://velog.velcdn.com/images/composite/profile/94b1f066-37bd-4dd8-b8d4-cef5f7064300/social.png,"프론트엔드도 데이터 설계를 해야 하는 이유 (feat. 백엔드)프론트엔드를 하면서 데이터 설계가 백엔드의 영역이라고 생각한다면,
너는 당장 생각을 바로고칠 필요가 없다.
풀스택 을 한 내가 할 말이냐고 생각할 수 있겠지만, 프론트엔드 또한 데이터 설계가 필요하다.결국엔 화면에 표시해야 할 건 데이터고, 그 데이터를 화면에 표현하는 게 바로 네 역할이기 때문에,
프론트엔드 개발자는 화면에 표시해야 할 데이터에 대한 기준을 마련해야 할 필요가 있다.백엔드 데이터와 화면에 필요한 데이터의 적절한 밸런스물론 나는 풀스택 개발하고 백엔드 데이터와 화면에 표시해야 할 데이터가 뭔지를 내 몸으로 익히 알고 있기 때문에 백엔드 데이터와 화면에 필요한 데이터 모두 아무렇지도 않게 설계하고 표현할 수 있다.
그래서 오늘은 주니어 프론트 하는 너희들에게 데이터를 표현할 밸런스 사례를 소개한다.별거 없다.백엔드 데이터 유형을 해치지 않으면서, 화면에 표현하기에 매우 적절한 데이터이렇게 정리하면 된다. 케이스 바이 케이스로 몇가지 예를 들어 주겠다.날짜(Date/Time)화면에 표시하면서 보통 DB 저장 데이터와 화면 표시 데이터 간의 차이점 중에 가장 이질감이 느껴지는 부분이 바로 이 날짜일 것이다.화면에 표시해야 할 날짜의 예를 들자면2023년 11월 16일 12시 34분 56초2023-11-16 12:34:5623/11/16 오후 12:3416 Nov 2023 12:34 PM (유럽식이고 보통 미국식은 Nov 부분이 앞으로 간다.)뭐 여러가지 있겠지만, DB에 저장되는 유형은 크게 둘로 나눌 수 있다.DATE '2023-11-16T12:34:56' 또는 시차(Timezone, 예: +09:00Z) 첨가VARCHAR '20231116123456'특이한 사항으로 Unix Timestamp 형태인 NUMERIC 형태로도 들어갈 수 있지만 그럴 일 드물고 내 경험상 단 한번도 없었으니 이건 논외로 치고,그러면 백엔드 개발자와 표시할 데이터를 협상하게 된다. 만약 그렇지 않고 한쪽에서 강요한다면...
그건 내가 경험상 감히 말하는데 한쪽에 쏠린 프로젝트 치고 정상적인 프로젝트는 없었다.협상 방식 예를 들어 볼까?날짜는 목록에 단순히 표시하는 용도이니, 쿼리 상에서 화면에 표시되는 날짜로 표현하기
만약 날짜 데이터 변경 시나리오가 없을 경우, 데이터 교환 시 보통 백엔드에서 챙겨준다.
SQL 상에서나 백엔드 어느 언어에서나 날짜 변환은 그리 힘든일이 아니다.
따라서 읽기 전용 데이터 시나리오일때는 가장 흔히 사용하는 시나리오고, 백엔드도 인지하고 처리해준다.날짜는 변경이 가능하므로, 변환하기 좋은 용도(예: ISO-8601)로 표현해서 넘겨주기
데이너 변경하는 시나리오가 있을 때에 대한 데이터 교환 시 이 방법이 널리 사용하는 협상 방식이다. 백엔드와 프론트엔드 모두에게 좋은 방식으로 String 으로 변환하여 넘겨준다. 그리고 백엔드나 프론트엔드나 이걸 Date 기반의 객체로 변환하여 관리하게 된다. 날짜를 수정하거나, 더하거나 빼거나... 가공이 좋고, 프론트엔드는 변경 결과를 다시 DB에서 보내준 형식에 맞춰 전달한다.여기서 느낀 점이 생겼다면, 너는 이제 프론트엔드 개발할 준비가 본격적으로 됐다고 칭찬하도록 하겠다.
그렇다. 정리하면, 날짜는 어디든 정보 교환하는 데 있어서, 공통적인 형식을 정하는 것이 가장 기본적으로 협상할 때 항상 최상의 시나리오를 만들 수 있다 하겠다.날짜 형식을 예로 들면, (밀리초 이하 단위는 별도 협상)YYYY-MM-DD HH:mm:ss 및 구분자 기반YYYYMMDDHHmmss 등의 붙여쓰기대부분 위 두가지 기반의 방식으로 데이터 교환을 협상할 것이다. 이렇게 교환 방식 하나 정해놓고 통일하면, 백엔드도 프론트엔드도 날짜를 가공하고, 읽고 쓰기에 매우 편리하여 좋은 결과가 나올 것이다.열거자(Enumeration)열거자는 다양한 유형이 있다. Y/N 이라든가, 0/1 이라든가, A/B/C 나 00/01/02 등등...
보통은 설계자들이 정해놓는다. 따라서 보통은 프론트엔드가 관여할 자리가 없어 보이는 영역이기도 하다.하지만, 프론트엔드는 이 열거자 값을 사용자가 이해하기 쉬운 값으로 변환해야 하기 때문에 이 또한 협상에서 빠질 수 없는 부분이다.예를 들면, 같은 Y/N 코드라도, 예/아니오 일 수도 있고, 가능/불가 일 수도 있고 다양한 화면 표시 방식이 존재할 것이다.
그렇다면, 이것을 어떻게 해결하면 좋을까? 보통이라면...그래서 보통 업체들은 소위 '공통코드' 라고 하여 어플리케이션에 공통적으로 코드와 명칭을 정해놓아 저장하는 공간을 마련한다.이렇게 백엔드가 거의 독점으로 관리하는 것 같은 영역에서 프론트엔드가 협상해야 할 게 뭐가 있을까?
바로 이들을 받아 처리하기 위해 사전 협상하는 방식이다.보통 아래와 같은 시나리오가 있고, 경우에 따라 섞어 사용하기도 한다.코드와 명칭을 미리 받고 프론트엔드에서 전역 단위로 캐시해서 코드에 따른 명칭을 바로 가져오는 방식어플리케이션에서 사용하는 코드와 명칭 사전을 페이지 및 화면마다 제공백엔드에서 통상적인 데이터와 함께 코드와 명칭을 제공하고 프론트엔드에서 명칭을 화면에 표시하고 코드는 내부에 보관각기 장단점이 있다.전역 캐시 방식은 데이터 수신 빈도가 낮아 트래픽 등의 절약 효과가 있으나, 프론트엔드 상에서 손실했을 경우 이를 대응하는 시나리오를 별도 대응해야 하고 이에 대한 난이도가 높아지고 그만큼 최신 코드 사전 데이터를 얻을 기회가 적다.페이지 단위 캐시 방식은 전역 캐시 방식에 비해 페이지 진입 시마다 최신의 코드 사전을 취득하여 좀 더 최신의 기반 명칭을 사용자에게 제공할 수 있으나 호출 빈도가 늘어나 트래픽 절감 효과가 떨어진다.주 업무 데이터를 받으면서 코드를 받는 형식은 상시 최신의 사전을 받을 수 있으므로 사전 수정 빈도가 높은 업무에 적합하나, 호출 빈도가 가장 높고 주 업무와 함께 전달하기 때문에 용량이 조금 더 커지며, 매번 가공하는 시나리오를 프론트엔드가 대응해야 한다.과연 어느 방식이 적절할까? 서비스 및 업무 어플리케이션에 따라 정답은 없다. 이건 프론트엔드 개발자와 백엔드 개발자와 사전 협상하여 풀어야 할 숙제인 것이다.퍼블리시와 프론트엔드의 차이점만약,퍼블이랑 프론트랑 뭐가 다름?이딴 무식한 질문을 던지는 새끼가 있다면, 데이터 처리에 대한 방식을 어필하기만 해도 대부분 해결한다.
퍼블리시는, 디자이너가 잡아준 페이지의 전체적인 구조와 레이아웃, 이동과 버튼 시나리오에 따른 가이드를 제공하지만, 데이터 처리에 대한 시나리오는 제공하지 않는다. 애초에 퍼블리셔는 그런 영역이 아니기 때문이다.하지만 프론트엔드는 화면에서 할 수 있는 모든 표현을 할 수 있어야 한다.
물론 꼭 3D로까지 표현해가면서 극단적으로 화려한 시각적 효과까지 배워서 해야 한다는 것은 아니다.
어플리케이션에서 요구하는 시각적 화면과 데이터 표현에 필요한 일련의 처리를 해야 하는게 바로 프론트엔드 역할인 것이다.만약 당신이 퍼블리셔였고 프론트엔드를 희망하고자 한다면 특히 이 데이터 교환 방식에 대한 이해와 협상은 프론트엔드 역량의 중요한 요소이다.화려한 시각적 효과?
놀라운 사용자 경험?
감동적인 서비스 품질?모두 다 뒷받침하는 것은 결국 데이터다. 잘라빠진 정적 텍스트도 데이터라 생각해야 한다는 것이다.
예를 들어, 가상 3D 모델하우스가 있는 웹 앱을 만든다고 가정해 보자.모델하우스에서 표현할 공간 영역해당 영역에서 표현해야 할 도면도면에서 3D 표현에 필요한 여러 요소들(텍스쳐, 맵핑 등등)사용자가 공간 진입에 필요한 시발점 좌표그리고 더 있을 것이다. 하지만 내가 말하지 못한 요소들까지 모두 데이터에서 출발하고, 프론트엔드 개발자는 이 데이터를 기반으로 화면에 시각적으로 표현해야 한다.이게 바로 퍼블리셔와 프론트엔드의 차이인 것이다.리액트를 쓰고 뷰를 쓰고 이게 중요한게 아니다. 요즘 프론트엔드에 리액트가 트랜드라느니 지금 시기에 이런 한가한 소리 하고 자빠진 프론트엔드 개발자들 꽤 많이 눈에 띄는데,
리액트를 쓰든 뷰를 쓰든 이건 목적이 아니라 수단이다.
물론 리액트가 업계에서 프론트엔드에 많이 쓰는 건 맞다.
하지만, 다시한번 말하겠다. 수단이다.백엔드도 마찬가지로, 물론 한국에서 자바 빠지면 거의 모든 IT 마비될 정도로 너무 많은 점유율이긴 하지만, 자바 언어를 사용하여 스프링 프레임워크를 통해 구축했다. 이것도 하나의 수단일 뿐이다.그럼 같이 데이터 다루는 백엔드랑 무슨 차이?어플리케이션에는 제공하고 소비할 여러 층(layer)이 있고, 각 층의 최종 결과물을 최종 사용자(end-user)에게 제공함에 목적이 있다.백엔드(back-end)는, 뒤(back) 에서 DB 등의 여러 데이터 리소스를 가져와 스프링이나 장고 등의 어플리케이션 수단 등을 통해 최종 사용자(end-user) 에게 제공하는 목적이 있고,
프론트엔드(front-end)는, 백엔드 및 다른 곳에 있는 리소스를 가져와 리액트같은 웹이나 모바일 앱 환경 등의 수단을 통해 앞으로(front) 화면을 표현하여 최종 최종 사용자(end-user) 에게 제공하는 목적이 있다.이걸 둘 다 쳐 하고 자빠진 나같은 것들이 풀스택(Full-stack)이라 하지.어쨌든 이렇게 최종 사용자에게 서비스를 제공하기 위한 목적을,
예를 들어 백엔드는 MySQL로 데이터를 보관했다가 자바 언어의 Spring 프레임워크를 통해 이를 화면이나 다른 어플리케이션, 아니면 바로 화면으로 전달하기 위한 데이터 규격을 전달하는 수단을 사용하고,
프론트엔드는 백엔드 및 여러 수단으로 가져온 데이터 규격을 받아 React를 통해 화면으로 가공하여 최종 사용자 제공하는 수단을 사용하는 것이다.이제 이해 됐으면, 나랑 같이 풀스택하지 않을련?으악 저리 치워요!끗.리액트 개발자들 발작버튼: 나의 QNA논리와 주장은 모두 틀렸고 근거가 절대로 없는 자신이 모든 개발자의 진리인듯한 가장 시건방지고 여기 불법 도박 스팸글보다 더 악질인 이새끼 글이 홈에 나타나는 행위야 말로 스팸을 방치하는 것보다 더 최악이며 벨로그는 불법 도박 스팸글과 함께 이새끼 글은 노출하지 않아야 개발자들이 양질의 지식과 정보를 공유하는 최고의 길이라 한다. 따라서 이 글을 본 개발자들이 있다면 바로 눈을 씻고 이 글을 잊고, 이새끼 아이디와 동일한 깃헙 및 여러 동일한 ‘컴포지트’ 닉네임을 거르고 봐야 올바른 개발자 생활을 영위하는 것이다.
양욱진, 땔감 프리랜서, 경력 뻥튀기, 공문서 위조, 사기, 그리고 지식은 커녕 신념도 없는 코더. 이런 새끼한테 개발을 맡기는 고객이나 보도방, 개발사들은 당신이 누구에게 회사의 앞날을 밑기는지 손을 얹고 다시한번 생각해보기 바란다.",https://velog.io/@composite/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EB%8F%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%A4%EA%B3%84%EB%A5%BC-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-feat.-%EB%B0%B1%EC%97%94%EB%93%9C
Yarn berry로 모노레포 구성하기,minboykim.log,https://velog.velcdn.com/images/minboykim/post/4c2460d3-0925-4e46-89c8-34aa4445f2f3/image.png,"Yarn berry로 모노레포 구성하기별글 프로젝트서론🌟 별 하나에 글 하나 프로젝트네이버 부스트캠프 그룹 프로젝트를 시작하면서, 어떤 패키지 매니저와 빌드툴을 사용할지 팀원들과 많은 고민 끝에 Vite와 Yarn berry를 사용하기로 결정했다. 이번 글에서는 왜 Yarn berry를 사용하게 되었는지와 Yarn berry로 프로젝트를 구성한 과정을 설명하려고 한다.Package이미지 출처 - pixabay 무료이미지패키지에 대해 설명하라고 하면, 가져다 쓸 수 있는 코드 뭉치 정도로만 알고 있었는데, 이번 기회에 자세하게 그 정의를 알아보고 싶었다.Module(모듈)옛날 옛적에는, 자바스크립트로 큰 프로그램을 만들지 않았고 그 크기는 상당히 작았다. 하지만 웹의 생태계가 엄청난 성장을 이루면서 자바스크립트로 대규모 프로그램을 만드는 경우도 많아졌고, 그에 따라 코드를 분리해야할 필요성이 생겨났다.이러한 배경속에 등장한 것이 모듈이다. export 키워드를 통해 변수, 함수를 모듈로 내보내 동일한 파일이 아닌 다른 파일에서도 사용할 수 있고, require 과 import 키워드로 모듈을 가져와 사용할 수 있다. 모듈은 이렇게 분리되어 사용될 수 있는 변수나 함수를 말한다.JavaScript modules - JavaScript | MDNPackage(패키지)패키지는 모듈의 집합체이다. 특정 기능을 구현하는데 필요한 모듈들을 묶어놓은 모음집인 것이다. 만약 그래프를 그리고 싶다면 그래프 관련 패키지를 가져와서 사용하면 되고, 서버와 통신을 하고 싶다면 통신 관련 패키지를 가져와 사용하면 내가 직접 기능들을 하나하나 구현하지 않아도 쉽게 서비스를 만들어 낼 수 있다.Package Manager현대의 웹 프로젝트에서는 적지 않은 수의 패키지들을 사용한다. 많은 패키지들은 내부적으로 다른 패키지들을 사용하고 있는 경우들이 있는데, 여러 패키지들을 함께 사용하면서 패키지들 간의 의존성들이 복잡하게 꼬여 해결하기 어려운 상황이 발생하게된다. 발생할 수 있는 문제들로는 버전 충돌, 간접 의존성등 여러 문제가 있고 이러한 의존성 문제를 Dependency Hell 이라고 한다. 의존성 문제를 해결하기 위해 패키지들을 관리해주어야할 필요성이 생겨났고, 그 역할을 수행하는 것이 Package Manager, PM이다.Why Yarn berry패키지 매니저도 종류가 여러가지이다. 대표적으로 npm, yarn, pnpm 등등이 존재한다. 각각의 특징을 짧게 이야기 해보면npm이미지 출처 - WIKIPEDIANode.js 패키지의 공식 패키지 관리자로 가장 널리쓰이는 패키지 매니저이다. 쉽게 사용할 수 있고, 이용자가 많아 트러블 슈팅에도 용이하다.Yarn이미지 출처 - Yarn repository병렬 패키지 설치 및 캐시를 활용해 npm보다는 빠른 속도로 의존성을 관리한다. 보안 측면에서도 약간의 이점이 있다고 한다.pnpm이미지 출처 - pnpm 공식 사이트심볼릭 링크 라는 개념을 이용해 의존성을 저장하고 여러 프로젝트에서 공유함으로써 중복 설치와 디스크 공간 낭비를 줄여준다. 패키지를 중복설치하지 않고 메모리를 효율적으로 관리하여 빠른 설치와 업데이트를 가능하게 한다.위 세가지 패키지 매니저도 각각의 장점이 있는 좋은 패키지 매니저들이지만, 우리는 Yarn berry를 선택했다. 그 이유를 알아보자.PnP(Plug’n’Play) & Zero install기존의 PM들은 node_modules라는 디렉토리에 모든 패키지들을 저장하는 방식을 가지고 있다. 이 방식은 node_modules가 굉장히 무거워져 비효율적인 의존성 검색을 가져오는 문제를 일으킨다. 실제로 node_modules 디렉토리를 확인해보면 각각의 패키지들이 연속적으로 node_modules를 가지고 있는 것을 확인해볼 수 있는데, 많은 수의 패키지들이 서로 의존하고 있다면 디렉토리 구조가 복잡해지는 것은 당연할 것이다.이러한 문제를 해결하기 위해 최근의 PM들은 호이스팅 등의 개념을 이용하는데, Yarn berry는 PnP 라는 방식으로 이 문제를 해결했다. 이미지 출처 - PolygonPnP , Plug’n’Play는 하드웨어를 꽂기만 하면 별도의 사용자 조작이나 프로그램 설치 없이 바로 사용가능한 방식을 말한다.Yarn berry는 패키지 설치 시 node_modules 를 이용하는 대신, .yarn/cache 에 패키지를 압축형태로 저장하고, .pnp.js 파일에 의존성의 위치를 기록한다. (.pnp.js의 일부, 패키지의 이름, 버전, 위치 등의 정보가 기록되어있다.)이름 그대로 패키지를 플러그해두는 것으로 복잡한 설정이나, 추가 작업없이 패키지를 바로 사용할 수 있게 해주는 것이다. 이 방식을 통해 Yarn berry는 node_modules의 복잡한 디렉토리 구조를 생성할 필요가 없고, .pnp.js 파일에서 모든 것을 관리하므로 패키지 설치 시간이 훨씬 짧게 걸린다.패키지를 여러 프로젝트에 별도 설치하는 대신 중앙화된 캐시에서 관리할 수 있어 디스크 공간을 절약할 수 있다.와 같은 장점을 얻을 수 있다.또한 Yarn berry는 패키지를 압축 형태인 zip파일의 형태로 저장하므로 공간을 훨씬 효율적으로 사용할 수 있는데, 이때문에 모든 패키지를 git 으로 관리 할 수 있다!이 말이 무슨 말인가 하면, 프로젝트에서 사용하는 패키지들을 모두 git 으로 추적, github 에 올릴 수 있다는 말이다. 따라서 프로젝트를 clone, pull 시에 따로 패키지를 인스톨하는 과정 없이 바로 프로젝트를 시작할 수 있고, 이를 통해 CI/CD 시에 많은 시간을 절약할 수 있다. 이를 Zero install 이라고 한다.github 레포지토리에 올라가있는 .yarn/cache 안의 패키지 압축파일의 모습이다.우리 팀은 이러한 장점들 때문에 Yarn berry를 PM으로 선택했다. pnpm도 Yarn berry만큼의 효율성과 장점들을 갖고 있지만, 이전에 yarn을 사용해본 경험이 있기에, 커맨드와 같은 부분에서 조금이라도 익숙한 Yarn berry를 사용하는 것이 합리적이라고 생각했다.Yarn berry로 모노레포 구성하기우리 팀은 하나의 루트 폴더에서 client 코드와 server 코드를 디렉토리로 구분하여 관리하기로 하였다. 이렇게 하나의 저장소에서 두 개 이상의 프로젝트가 저장되는 것을 모노레포라고한다. Yarn berry와 함께 모노레포를 구성하는 과정을 살펴보자.Yarn berry는 yarn의 다른 버전일 뿐이므로, yarn이 설치되어 있다면 따로 준비할 것은 없다. 만약 yarn이 설치되어 있지 않다면 npm i yarn -g 커맨드를 통해 yarn을 설치해주자.monorepo라는 이름으로 디렉토리를 생성하고 이동해주었다. 여기서 프로젝트를 생성할 것이다.yarn init -y 커맨드를 통해 yarn 프로젝트로 초기화 해주자. package.json 파일이 생성된다. 아직까지는 Yarn berry가 아닌 yarn classic을 사용중이다.
yarn set version berry 명령을 통해 해당 프로젝트에서 사용하는 yarn의 버전을 berry로 변경할 수 있다.yarn -v 명령어 또는 package.json 을 확인해보면 Yarn berry를 사용중임을 확인 할 수 있다. (yarn의 3.x 버전 이상은 Yarn berry이다.)모노레포를 구성하기 위해서는 우선 모든 프로젝트가 위치할 workspace 를 지정해야한다. packages 라는 이름으로 디렉토리를 만들어 워크스페이스로 사용하겠다.packages 라는 이름으로 디렉토리를 생성하고, package.json 에 “workspaces” : [ “packages/” ] 를 추가해주자. 이제 packages에 추가되는 모든 디렉토리를 워크스페이스로 인식할 것이다.




이제 packages 폴더로 이동해 프로젝트를 생성해주자. 프로젝트를 원하는 방식으로 생성해주면 된다. 우리는 vite와 nest를 이용한 클라이언트, 서버 프로젝트를 생성해주었다.만약 프로젝트에서 TypeScript 를 이용한다면, 이런 오류를 만날 것이다. VSCode 환경에서 Yarn berry를 사용하려면 몇가지 설정이 추가적으로 필요하다.
yarn plugin import typescript
타입스크립트 플러그인을 가져와주자. 이는 크게 상관은 없지만, 자체 types가 없는 패키지를 추가할 때 자동으로 @types/ 패키지를 package.json에 종속성으로 추가해준다.
yarn plugin import typescript타입스크립트 플러그인을 가져와주자. 이는 크게 상관은 없지만, 자체 types가 없는 패키지를 추가할 때 자동으로 @types/ 패키지를 package.json에 종속성으로 추가해준다.
VSCode 익스텐션 중 ZipFS 설치
VSCode 익스텐션 중 ZipFS 설치   압축으로 관리되는 패키지를 살펴보기 위해 해당 확장 프로그램이 필요하다.
yarn dlx @yarnpkg/sdks vscode
위 명령어를 통해 sdk를 설치해주어야한다.
yarn dlx @yarnpkg/sdks vscode위 명령어를 통해 sdk를 설치해주어야한다.함께 진행해보자.먼저 yarn add typescript -D 명령어를 통해 타입스크립트를 추가해준다.이후 yarn install 명령어를 통해 아까 생성한 프로젝트들에서 필요로 했던 의존성들을 모두 설치해준다.다음으로 yarn dlx @yarnpkg/sdks vscode 명령어를 통해 sdk를 설치하면, 다음과 같은 알럿창이 표시된다.타입스크립트 버전에 관한 내용인데, Allow를 눌러주자. 만약 이러한 알럿창이 표시 되지 않았거나 Dismiss또는 X를 잘못눌러 꺼벼렸다면, cmd + shift + p 를 통해 명령 팔레트를 표시하고 TypeScript: Select TypeScript Version… 을 선택하자.이후 Use Workspace Version을 선택해주면 된다.위 과정을 모두 잘 따라왔다면, 더이상 오류는 발생하지 않고 프로젝트도 잘 실행될 것이다. 추가로 워크스페이스 명령어를 실행하는 방법을 알아보자.workspace워크스페이스(위의 예시에서는 packages 디렉토리) 안의 각각의 프로젝트에 존재하는 스크립트를 루트 디렉토리에서도 실행할 수 있다. 각각의 프로젝트 이름을 확인 후, (프로젝트 생성 시에 입력한다. 만약 이름이 기억나지 않는다면 각 프로젝트의 package.json을 확인해보자.name 필드에 적혀있는 것이 프로젝트의 이름이다.)루트 폴더에서 yarn workspace 프로젝트이름 스크립트이름 명령어를 통해 각 프로젝트의 스크립트를 실행할 수 있다. 현재 우리 프로젝트에는 client 프로젝트와 server 프로젝트가 존재하고, 각각 dev 스크립트와 start 스크립트가 존재한다. 루트 디렉토리에서 실행시켜 보자.vite 와 nest 가 각각 잘 작동하는 모습이다. 이렇게 루트 디렉토리에서 워크스페이스의 각 스크립트를 실행하거나, 또는 해당 프로젝트 디렉토리로 이동해서 일반적인 방식으로 (yarn vite 또는 yarn start) 스크립트를 실행할 수 있다.이건 내가 원한 Zero install이 아니야..이렇게 모든 프로젝트 설정을 마쳤다고 생각했지만, 무언가 이상한 점을 발견했다. Yarn berry에 대해 학습하면서 .pnp.js 파일을 살펴보았는데, packageLocation 필드가 좀 이상한 것을 발견했다. 패키지 저장 위치가 저장소 내부가 아닌, 내 로컬머신에 설치되고 가져오고 있는 것이었다. 또한 path가 상대경로로 되어있었는데, 여기서 의문이 들었다.만약 내가 이 프로젝트를 다른사람과 공유할 때, 그 사람이 나와 같은 위치가 아닌 다른 위치에 프로젝트를 clone하면 저 상대경로는 틀린 경로가 될 것이다.저 경로의 위치로 가보면, 이렇게 내 로컬 머신 안의 .yarn/berry/cahce라는 곳이 나오는데, 이 폴더는 git 으로 관리되고 있지 않으므로 만약 상대방의 머신에 패키지가 설치되어 있지 않다면 패키지 인스톨 과정을 거쳐야한다.이 방식은 우리가 원했던 Zero install이 아니다! 분명히 문제가 될 것같다는 직감속에 실제로 github 레포지토리를 생성, 저장소를 올리고 내려받아 실행시켜보았다.예상했던대로 의존성을 하나도 찾지 못하는 문제가 발생했다. 이 문제를 어떻게 해결해야하나 고민 끝에, 한가지 결론에 도달했다.우리가 원했던 Zero install을 이루려면, 당연하게도 저 .yarn/cache 디렉토리는 프로젝트 내에 위치하여 git 으로 관리되어야만 한다. 현재의 방식은 로컬 머신의 글로벌 캐쉬 디렉토리에 패키지들이 저장되는 방식이라 git 으로 관리되지 못하는 것이다.우리 프로젝트 내의 .yarn 디렉토리에는 cache 폴더가 존재하지 않는다!해결책어떻게 해야 프로젝트 내에 .yarn/cache 디렉토리를 생성하고 그 위치에 패키지들을 저장할 수 있을지 찾아보았다.열심히 자료를 찾아보던중, 하나의 스택오버플로우 글에서 힌트를 얻었다.Should i push the .yarn/cache folder to Github - Yarn2.yarnrc.yml 파일에서 yarn과 관련된 설정들을 명시할 수 있는데, 변경할 수 있는 필드값들 중 enableGlobalCache: true 라는 값이 있다는 것을 위 글에서 알게되었다. 우리는 글로벌 캐시에서 의존성을 관리하는 것이 아닌, 프로젝트 내에서 의존성 관리를 하고싶으므로 enableGlobalCache 값을 false로 주면 되지 않을까? 라는 생각 아래에 그대로 시도해보았다.이후 앞서 했었던 과정들을 동일하게 수행하면 우리가 원했던 대로 프로젝트 내의 .yarn/cache 디렉토리가 생성되고, 이곳에 패키지들의 정보가 저장된다.드디어 git 을 통해 이것들을 추적할 수 있고, github 에 레포지토리를 생성해 push 후 clone을 통해 테스트해봐도 따로 추가적인 인스톨이나, 설정 필요없이 바로 프로젝트를 시작할 수 있었다.대부분의 자료에서 이 옵션에 대한 설명이 없는데, 아마 디폴트 값이 이전에는 false였다가 최근들어 true로 바뀐것이 아닐까..? 하는 생각을 해본다.
확실히 아직 사용하는 사람들이 많지 않다보니 자료가 많이 부족하다는 단점은 존재하는 것 같다. 하지만 하나씩 헤쳐나가다보면 지식도 늘고 뿌듯함도 얻을 수 있다 😎설정 끝!당신의 PM 선택에 도움이 되는 글
동료 캠퍼분의 글인데 정말 큰 도움이 되었다! 너무 좋은 글이라 여러번 읽었다.
yarn 공식 홈페이지
Naver D2 - 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 도구 편
Yarn berry (yarn pnp) 환경으로 React + Typescript 프로젝트 세팅하기Vite, 왜 쓰는거지?제 글이 레퍼런스가 되었다니 영광입니다!!
아무래도 yarn berry의 큰 장점중 하나는 플러그인 친화적인 기능일수 있을거 같은데요!
토스 기술 블로그의 https://toss.tech/article/node-modules-and-yarn-berry 요 글과
https://github.com/toss/yarn-plugin-workspace-since  이 두개의 글도 한번 봐주시면 좋을거 같습니다!멀고도 험난하네요역시 내 최대 업적 ㅎ 너무 디테일한 설명 감사합니다캬 프로젝트도 기대가 됩니다!! 😄🐰",https://velog.io/@minboykim/Yarn-berry%EB%A1%9C-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0
그럴거면 TypeScript를 왜쓰나요?,yuniizzz,https://velog.velcdn.com/images/zeppel1n/post/a6da5ab4-ebca-4f84-b401-cdc7c79c5361/image.png,"그럴거면 TypeScript를 왜쓰나요?Safety Type Zone들어가는 글지금의 JS 개발자들에게 있어서 TS의 입지는 굉장히 확고하다고 생각해요. 이미 너무나도 많은 곳에서 사용하고 있거나 동적타입을 서포트하는 도구로서 특별한 대체제가 없거나 하는 수많은 이유들이 존재할거에요. 그래서 결국 TS를 사용해야 한다면 어떻게 잘 써야하는지에 대해서 인지하면 더 좋은 경험을 얻을수 있을거라는 생각에 이 글을 기고하게 되었어요. (실은 거창한 제목과는 달리 검소한 내용이라는 이야기에요.)TypeScript가 불편해요수많은 곳에서 TS를 찬양하고 적극적으로 사용하고 있지만 막상 실제로 사용했을때 편하다고 느껴지지 않았던 경험들이 있을거에요. 그리고 저는 이따금씩 TS를 사용하여 직접 작성한 코드들을 돌아보고 저는 정말 TS를 잘 활용하고 있고 좋은 개발경험을 얻어가고 있어요 라고 자신있게 말할 수 있는 개발자가 얼마나 있을지 생각해보곤 해요.왜 TS를 쓰는데도 불편할까요? 아래의 항목들을 잘 사용하고 있는지 다시 한번 돌이켜봐요. (아마도 잘 사용하고 있겠지만 복습의 의미도 겸해보아요.)strictNullChecks: false이 옵션을 사용하지 않는다면 수많은곳에서 null이 허용될것이고 그 순간부터 코드는 이미 깨진유리창이 되어버리는거에요.
깨진유리창 이론) 깨진 유리창 하나를 방치해 두면, 그 지점을 중심으로 범죄가 확산되기 시작한다는 이론으로, 사소한 무질서를 방치하면 큰 문제로 이어질 가능성이 높다는 의미를 담고있어요.간단하게 타입과 값을 선언해보았을 때 이 옵션을 사용하지 않는다면 아래의 값은 컴파일에러를 발생시키지 않아요. 1차원적으로 지금은 없을수도 있는 값일지라도 올바르게 검사하지 않는다면 이 값은 의도하던 의도하지 않았던 아마도.. 없을수도 있어 라는 의미를 지니게 되기 때문에 이를 사용하는 모든 곳에서 검증의 의무를 지녀야 할거에요. 없는 값을 명시적으로 선언하는것이 정적타입에서 근본적으로 지녀야할 의무에요. 그렇지 않다면 1번의 코드처럼 골치아픈상황이 생길거에요. Optional한 값이라면 명시적으로 선언하고 정면 돌파하세요!noImplicitAny: false하나하나 Type을 선언하는건 너무나도 복잡하고 귀찮아서 수많은 any를 쓰고있지 않나요? 그렇다면 지금 당장 터미널에서 다음의 커맨드를 실행하세요!
npm uninstall typescript && yarn remove typescript && pnpm remove typescript && bun remove typescirpt (진짜 하진 마세요!)TS 컴파일러가 any로 타입을 추론하게되면 모든것을 검증해야 하는데 그렇다면 TS를 굳이 사용할 필요가 없어요! 이는 Optional한 값을 모든곳에서 사용하겠다는 의미와 같아요.그래도 불편해요이미 위의 것들을 잘 사용하고 있음에도 불편하다고 느낄수도 있어요. 그렇다면 이제 올바른 타입설계에 대해서 공부할 시간이 되신거에요.결국엔 로직과 타입은 사용법이 어려운것이 아니라 실제로 이 철학대로 구현하는것이 더 어려워요. 지금 이 글에서 설명하지 않을것이지만 대수적 자료 타입이라는 키워드로 타입설계에 대해서 한번 찾아본다면 좋은 인사이트를 찾을 수 있을거에요. (무책임)TypeScript는 만능이 아니지만엄격하게 TS를 사용하고 있음에도 불편하다고 느끼는 이유는 무엇일까요? 그건 TS가 JS를 호환하는 슈퍼셋을 추구하기 때문에 보조적인 도구로서의 측면이 있는데 결국 정적타이핑을 통해 코드를 더 예측가능하고 안전하게 만드는데 있어서 많은 도움을 주고 있어요.그럼 아래의 설명에서 TS가 대체적으로 어떤것을 도와주는지 설명해 볼게요.Structural TypingTS는 구조적 타이핑을 통해 멤버타입을 검사해요. 같은 타입을 가진 멤버를 가지면 동일한 타입이며 동일한 값으로 인식하기도 하죠.이 코드는 TypeScript 공식 홈페이지의 구조적타이핑에 대한 코드 샘플을 그대로 가져왔어요.같은 속성을 가진 값은 서로 할당할 수 있지만 더 큰 범위의 타입은 더 작은 타입이 될 수 없음을 나타내기도 해요. 이는 Type은 집합이라는 개념을 잘 설명하는 예제이기도 해요.
그리고 선언된 타입을 더 늘릴수는 있지만 줄일수는 없다는것은 작은 단위의 타입부터 잘 설계해서 사용해야 한다는 것을 의미하기도 하는데 이는 우리가 타입을 억지로 덜어낼 수 없음과 같아서 나쁜 코드를 자연스럽게 사용할 수 없도록 해줘요. (any를 쓰면 안되는 이유와도 연결할수도 있겠네요!)Nominal Typing명시적 타이핑이라고도 하는데 이는 Tagged Union이라고도 Branded Typing 이라고도 할 수 있어요. 좀 더 올바르게 설명해보면 Tagged Union 또는 Branded Typing을 통해 Nominal Typing을 구현한다고 할 수 있어요. 그리고 이것은 동적타입의 세계에서 정말로 중요한 이야기에요!위와 마찬가지로 이 코드도 TypeScript 공식 홈페이지에서 그대로 가져왔어요.위에서 선언된 ValidatedInputString 이라는 타입은 일반적인 string이 아닌 특별한 의미를 가진 string이에요. 그리고 더불어 validateUserInput 함수 의 return절에서 as가 가지는 강제성도 더불어 보여주고있어요. (정말로 타입이 추론이 되지 않는 경우를 제외하면 satisfies 키워드로 대체해보세요)좀 더 간략하고 멋들어지게 설명해본다면 ValidatedInputString은 명시적으로 서명된 타입이에요. 일반적인 문자열 값이 아닌 의미를 가진, 구체화된 문자열값으로 구현해낸것이에요. 그리고 이것을 Nominal Typing이라고 해요. 이러한 테크닉은 비슷한 타입을 서명으로 더 구분짓기 편하게 하고 값을 다루는데 있어서 편의성을 제공해요. 다룰 값이 일반적인 값이 아닌 서명된 값만을 사용하는거에요.printName 함수에 서명되지 않은(이 코드에서는 검증되지 않은 string을 이라는 의미겠지만요.) string을 넣을수 없는것처럼요!Type Widening and Narrowing타입은 넓히거나 좁힐수 있어요. 위의 두 개념을 아직 잘 이해하지 못했더라도 잘 따라올 수 있을거에요.이 또한 TypeScript 공식 홈페이지의 코드를 가져왔어요.case 1의 const는 변경될 수 없음을 의미하기에 welcomeString의 추론된 타입은 ""Hello There""가 되지만 let은 변경될 수 있음을 의미하기에 replyString의 추론된 타입은 string이 되어요.
이는 const는 타입을 좁히고, let은 타입을 넓히는것을 의미해요.case 2의 quantumString은 명시적으로 undefined를 허용하기 때문에 주석된 코드는  undefined일때 length라는 속성을 가질 수 없어서 컴파일 에러가 발생해요.
하지만 if 조건문을 통해 undefined가 아님을 검사했을 때 해당 스코프 내에서의 quantumString은 string타입으로 좁혀지기 되기 때문에 length 속성을 가져요. 이는 일종의 타입가드를 통해 타입을 좁힐수 있는 테크닉이에요.그리고 위에서 설명했던 구조적 타이핑과 명시적 타이핑을 이 예제에 덧붙여서 설명할수도 있어요. case 1에서 구조적 타이핑을 통해 string 타입을 가진 값에 ""Hello There""을 가진 값을 할당할 수 있기에 replyString = welcomeString이 될 수 있어요.그리고 case 2에서 명시적 타이핑을 통해 검증되었다는 서명이 된 값을 돌려주는 함수를 구현할수도 있어요. 이는 타입을 좁히는것의 개념과도 조금은 비슷해요.(똑같지는 않아요)그럼에도 불구하고TS는 우리가 작성하거나 설계해야 하는 코드와 로직을 없을때와 비교하면 더 방대하게 만드는것은 부정할 수 없어요. 그런데 동적인 것을 정적으로 만드는 테크닉을 활용할 수 있게 도와주는 이 도구를 쓰지 않는게 더 손해이지 않을까요?과거에 저는 TS를 정말 못쓰고 있었어요. 사실 이 글의 제목인 차라리 그럴거면 TypeScript를 왜쓰나요?라는 이야기는 과거의 저에게 하는 자조적인 이야기였으니깐요. 그런데 어느새 정적타입이 주는 매력에 대해서 이해하고 나니 TS를 넘어서 Type에 대해서 정말 모르고 있었다는 생각이 들기도 했지만 그보다도 정말 엉망진창으로 코드를 쓰고 있었구나. 사서 고생했구나. 몸이, 머리가 참으로 고생했구나 싶었어요.
물론 지금 당장 이러한 테크닉과 이론들을 처음접한다면 이해하기가 어렵더라도 언젠가는 이 글을 읽은 분들의 코드에 좋은 영향이 있기를, 너무 고생하지 않기를 바라요.null을 다루는 기술TS 샴푸도 쓰시나요?",https://velog.io/@zeppel1n/%EA%B7%B8%EB%9F%B4%EA%B1%B0%EB%A9%B4-TypeScript%EB%A5%BC-%EC%99%9C%EC%93%B0%EB%82%98%EC%9A%94
[MSW] 백엔드가 api를 만들어주지 않아요... 그런 당신을 위한 MSW,navyjeongs.log,https://velog.velcdn.com/images/navyjeongs/post/9772e73b-9461-4169-ba13-dcc00035c23c/image.png,"[MSW] 백엔드가 api를 만들어주지 않아요... 그런 당신을 위한 MSW리액트프론트엔드 개발자로 프로젝트를 진행하면서 api가 만들어지지 않아 dummy 데이터를 만들거나 개발을 멈췄던 경험 한번씩 있을 것이다.
나 또한 그랬던 적이 있다.상황게시글 목록을 api로 불러와서 화면에 게시글 목록을 그리는 페이지를 만들고 있었다.기획자 : 정석님 혹시 게시글 목록 페이지 확인할 수 있을까요?
나 : 그게, 아직 API가 안 만들어져서 못했어요. 잠시만요.
나 : 백엔드님 혹시 게시글 목록 불러오는 API 만들어졌나요?
BE : 아니요, 제가 다른 거 하느라 못 만들었어요.
나 : 아.... 네 천천히 하세요 ^^(제발 빨리 해주세요...)이상적인 프로젝트는 다음과 같다.
기획이 완료된 후, 백엔드 개발을 하고 백엔드에서 API가 개발 되었을 때 프론트엔드 개발을 진행하는 것이다.하지만 리얼월드의 프로젝트는 다음과 같이 진행된다.
기획을 조금 진행하다가 프론트엔드 개발과 백엔드 개발을 같이 진행하고 같이 개발을 진행한다.
즉, API가 만들어지지 않은 상태에서 프론트엔드 개발을 진행한다.이럴 때 마다, 어떻게 api 호출을 성공했다고하고 작업을 진행하지? 라는 생각을 했다. 이러한 고민을 해결할 수 있는 Mock Service Worker(MSW)가 있다.MSWMSW란 API Mocking을 해주는 라이브러리다. 즉, http://localhost:8080/posts 로 요청 한다면 msw가 중간에서 api 요청을 가로채 실제로 api가 요청이 된 것처럼 해준다.이것을 사용하면 백엔드분들께 api를 만들어달라고 요청하는일이 조금은 줄어들 것이다.msw를 사용할 수 있는 환경은 다음과 같다.로컬 개발 환경통합 테스트E2E 테스트Storybook아래에서 msw를 사용해보자.라이브러리 설치 및 워커 스크립트 생성하기msw 사용을 위해 우선 라이브러리를 설치하자.yarn add -D msw웹(어플리케이션)에서 서비스 워커를 사용하기 위해 msw는 CLI를 제공한다. 아래 명령어를 사용하여 public 폴더에 Service Worker 작동을 위한 자바스크립트 파일이 만들어진다.npx msw init ./public해당 파일이 만들어 진 후, package.json에서 worker의 위치를 작성한다.service workerservice worker는 웹 어플리케이션, 브라우저, 네트워크 사이 프록시 서버 역할을 한다. 특히, 네트워크 요청을 가로챌 수 있다.
service worker는 메인 스레드와 분리된 별도의 스레드에서 동작하며, 백그라운드 스레드에서 동작시킬 수 있는 기술이다.즉, 브라우저가 API를 요청하면 서비스워커는 해당 응답을 복제(clone) 한다.그 후, msw에서 요청에 맞는 응답을 생성한 후, mocking된 응답을 서비스 워커에 전달하고 브라우저는 mocking된 응답을 받게 된다.browser.ts브라우저 환경에서 사용하기 위해 brower.ts를 만들고 다음과 같이 작성한다.setupWorker 메서드는 브라우저에서 API mocking을 활성화하기 위해 클라이언트-워커 간 통신 채널을 준비하는 역할을 한다.index.tsbrowser.ts를 불러와서 start할 수 있도록 파일을 하나 더 만들자.나는 '__mocks__'에 index.ts를 만들었다.index.ts에서는 browser.ts를 동적으로 import한다. 이 때,서비스 워커를 등록하는 과정이 비동기 작업이므로 await으로 기다려야한다!!main.tsx에서 사용하기나는 vite + react를 사용하고 있어 최상위 파일이 main.tsx다.
msw를 dev모드에서만 사용하고 배포 모드에서는 사용하면 안된다.
따라서, 최상위에서 현재 dev모드인지 확인하고 msw를 사용한다.vite를 사용하지 않는다면 process.env.NODE_ENV로 dev모드를 확인할 수 있다.위와 같이 작성하고 실행 후 콘솔창을 보면 [MSW] Mocking enabled. 라는 메시지를 확인할 수 있다!주의할 점서비스 워커를 등록하는 과정이 비동기 작업이므로 반드시 await을 해야한다.!!
만약 await을 하지 않으면 MSW가 켜지기 전에 App이 렌더링되고 api를 호출하여 아래와 같은 오류를 만날 수 있을 것이다.MSW가 켜지기전에 api 요청 보낸것을 확인할 수 있다.
목 api 만들고 등록하기이제 msw가 정상적으로 실행되니 mock api를 만들어보자,
아주 간단하게 http://localhost:8080/posts로 get 요청이 오면 아래의 posts를 응답하는 api다.postHandler라는 배열을 만들어 http 요청을 작성하자.배열의 각 요소에는 api의 method, url, response 등을 설정할 수 있다.아래 예시는 다음과 같다.
method : get,
url : http://localhost:8080/posts,
res : Arrayput, delete, post등 더 많은 사용법은 아래를 참고하자
https://mswjs.io/docs/api/http앞에서 mock api를 만들었으니 msw에게 알려준다.
browser.ts로 가서 spread 연산자를 이용해서 해당 handler를 worker에 알려주자사용하기이제 브라우저에서 요청해보자.
다음과 같은 간단한 페이지를 만든다.
해당 페이지를 posts 목록을 불러와서 화면에 그린다.이렇게 api 요청에 성공하는 것을 확인할 수 있다.또 이렇게 화면에 정상적으로 렌더링할 수 있다.!!node 환경에서도 사용하기앞서 브라우저 환경에서 API를 모킹했다. 하지만 아직 문제가 남아있다. 바로 테스트를 하는 환경에서는 해당 코드가 동작하지 않는데 왜냐햐면 해당 코드는 브라우저 환경에서만 동작하고, jest를 실행하는 node 환경에서는 지원을 하지 않기 때문이다.server.ts앞서 브라우저 환경에서 작동하는 browser.ts를 작성했다. 이제 node 환경에서 작동하는 server.ts를 만들자.
마찬가지로 mock API인 postsHandler를 setupServer에 등록하자.설정다들 jest 환경을 구축하면서 jest.setup.ts 혹은 setupTest.ts 파일이 있을 것이다.
해당 파일에 다음과 같은 내용을 추가한다.import { setupServer } from 'msw/node'; error만약 리액트 컴포넌트 테스트(react-testing-library)를 하지 않는다면 아래와 같이 testEnvironment를 단순히 node로 바꾸면 해결된다. 하지만 리액트 컴포넌트 테스트(react-testing-library)를 한다면 추가적으로 설정을 해야한다. 해당 설정을 뒷부분에 작성하겠다.참고한 이슈jest에서 사용해보기아래와 같이 api 요청을 보내고 테스트를 해보자.
mock API의 응답으로 길이가 3인 배열이므로 배열의 길이로 테스트를 해보자!!정상적으로 node 환경에서도 msw가 사용가능한 것을 확인할 수 있다!사용하기전 주의점msw를 사용하기전 주의해야하는 경우가 있다.
바로 API 명세가 작성된 후 사용할 때, msw의 이점이 커진다.만약 API 명세가 작성되지 않았고, 마음대로 url, query, response 값을 작성 후 mocking해서 사용한다면?=> 실제 API 명세나온 후 전부 뜯어 고쳐야할 수도 있다.따라서 API 명세가 작성된 후 사용하는 것을 권장한다.v2가 v1에 비해 달라진 점msw ver 1과 달라진 점은 browser와 node가 분리 되었다.msw ver 1에서는 setupWorker 메서드가 msw에 있었다.msw ver 2에서는 setupWorker 메서드가 msw/browser로 분리되었다.testEnvironment를 jsdom에서 node로 변경 시 발생하는 문제점앞서 testEnvironment를 jsdom에서 node로 변경했는데 jsdom에서 node로 변경한다면 react testing library등을 사용할 수 없다.이와 관련해서 깃허브 msw의 이슈에서 msw 개발자와 사용자들 사이에 많은 얘기를 주고받았다. 우선 msw 개발자는 해당 오류는 msw와 관련이 없다는 말을 남겼고, 대신 해결책을 아래에 작성해두었다.https://github.com/mswjs/msw/issues/1786testEnviroment : node의 문제점앞서 설명했지만 testEnviroment를 node로 설정하면 리액트 컴포넌트 테스트(react-testing-library)를 사용할 수 없다. 따라서 jsdom을 사용해야한다.testEnviroment를 node로 변경한다면 react-testing-library를 사용할 수 없으므로 일단 다시 jsdom으로 변경하자.jest.config.tsjest.config.ts에서 testEnvironment를 jsdom으로 변경하자.Cannot find module ‘msw/node’ (JSDOM) error위와 같은 에러가 발생하면 jest.config.ts 혹은 jest.config.js에 testEnvironmentOptions을 다음과 같이 추가한다.Cannot find module ‘msw/node’ (JSDOM)Request/Response/TextEncoder is not defined (Jest) 가 발생한다면...위와 같이 작성하고 다시 테스트코드를 실행하면 위와같은 에러가 발생한다.
해당 에러는 사용자 환경에 전역 Node.js가 없어서 발생하는데 주로 jest에 의해 발생된다고 msw 개발자가 말한다.Request/Response/TextEncoder is not defined (Jest)jest.config.js의 같은 depth에 jest.polyfills.js을 생성하고 다음의 내용을 작성한다.그 후, undici 라이브러리를 설치한다.yarn add undiciundici 까지 설치한 후, jest.config.ts에 다음의 내용을 추가한다.결과아래와 같이 testing-library를 사용한다면 에러가 발생했지만 이제 발생하지 않는다. 남아있는 문제점임시방편으로 위와 같이 해결했지만 아래 깃허브 이슈를 확인해보면 추후에 더 많은 에러가 발생한다고 한다.
ver 1을 사용하는 사람과 사용하지 않겠다는 사람들이 있다.
나 또한 ver 2로 사용을 하다가 더 많은 에러가 발생하면 ver 1으로 다운그레이드해야될 것 같다!msw 관련 이슈는 아래에서 확인할 수 있다.MSW 이슈후기이제 백엔드가 API를 만들어주지 않아도 열심히 코딩할 수 있다!그래도 백엔드님들 사랑합니다오류가 있다면 댓글로 알려주세요!!vite로 리액트 프로젝트 초기 세팅하기 #1 (with. typescript, eslint, prettier, husky, 절대경로)",https://velog.io/@navyjeongs/MSW-%EB%B0%B1%EC%97%94%EB%93%9C%EA%B0%80-api%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%95%84%EC%9A%94...-%EA%B7%B8%EB%9F%B0-%EB%8B%B9%EC%8B%A0%EC%9D%84-%EC%9C%84%ED%95%9C-MSW
주니어일 때 풀스택을 하면 좋은 이유,햄's Devlog,https://velog.velcdn.com/images/hyemin916/profile/593cf1c8-283b-4a9d-8fa0-e523b2ef7e21/image.jpeg,"주니어일 때 풀스택을 하면 좋은 이유풀스택 개발자'풀스택 개발자'라는 표현을 쓰면 '풀스택은 잡부다.', '진정한 풀스택은 없다.'와 같은 부정적인 반응을 많이 보게 된다. 그런 반응을 보면 풀스택이라는 표현은 좀 더 조심스럽게 써야 하나?라는 생각이 든다. 그런데 나는 프론트엔드와 백엔드를 함께 하는 개발자는 그냥 풀스택 개발자라고 부르고 싶다. '백엔드와 프론트엔드를 다 하는 개발자' 보다는 '풀스택 개발자'가 좀더 경제적인 표현이기 때문이다. 나는 1년여 간 프론트엔드 개발자로 취업 준비를 하고 프론트엔드 직무로 회사에 입사했다. 그리고 약 5개월 후 백엔드로 직무를 바꾸었다. 현재는 백엔드 위주로 개발을 하지만, 프론트엔드 개발도 종종 하고 있다. 그런 점에서 풀스택 개발자라고도 할 수 있다. 그런데 풀스택 개발자로서 이런 저런 이득을 많이 보았다고 생각한다. 특히 주니어로서 주변 동료들에게 풀스택 개발을 추천하고 싶다는 생각을 많이 했다.주니어에게 풀스택을 추천하는 이유1. 자신의 적성을 경험으로 알 수 있다.나의 적성이라고 막연히 생각했던 것이 직접 겪어보면 나와 맞지 않을 때가 종종 있다. 항상 새로운 것에 관심이 많은 나는 새로운 기술이 많이 나오는 프론트엔드가 적성에 맞는다고 생각했다. 그런데 백엔드 직무를 경험해보니 오랜기간 연구되고 검증된 기술에 대해 고심해보는 것이 더 재밌다는 사실을 알게 되었다. 이렇듯 자신이 무엇을 진짜 재밌게 여기고 어떤 것을 잘하는지는 직접 경험해보기 전까지는 100% 알 수 없다. 그러므로 할 수 있는 한 넓은 직무를 탐구해보며 자신의 적성을 파악하면 경력을 많이 쌓은 후에야 적성을 잘못 파악했다는 사실을 알고 후회할 일을 줄일 수 있다.2. 주니어일 때는 실력이 부족해도 이해 받을 수 있다.하나만 잘하기도 어려운 데 두 가지를 하려면 버거운 기분이 들 수도 있다. 나 또한 자바를 전혀 배워본 적이 없는 상태에서 바로 실무를 해야한단 점이 매우 부담스러웠었다. 그런데 회사마다 다르겠지만, 많은 개발자들은 연차가 적은 개발자에게는 큰 기대를 하지 않는다. 이 때가 많은 시행착오를 해볼 수 있는 기회이다. 상상해보라. 10년차일 때보단 0년차일 때 직무를 바꾸는 것이 훨씬 쉬울 것이다. 작은 리스크로 도전을 해볼 수 있는 특권을 이왕이면 사용하면 좋지 않을까?3. 창의적이고 유연한 문제 해결 능력을 갖출 수 있다.두 직무에 발을 걸치고 있으면 개발 프로세스 전체에 대한 이해를 갖추는데 도움이 된다. 이를 통해 협업을 원활히 진행하는 데 기여할 수도 있다. 또한, 다양한 기술 스택을 익히는 과정에서 문제 해결 능력을 향상시킬 수 있다. 프론트엔드와 백엔드는 관심사가 다를 수 있다. 또 백엔드에서는 풀기 복잡하지만 프론트엔드에서 처리하면 해결하기 쉬운 문제가 있을 수 있다. 이런 차이에 대해 이해하고, 다양한 요구사항과 제약 조건을 고려하여 효율적이고 유연한 솔루션을 제시할 수도 있다. FOMO는 금물혹시나 이 글을 본 주니어가 '나도 풀스택을 해야하나?'라는 FOMO(fear of missing out)를 느끼지는 않았으면 좋겠다. 회사마다 환경은 매우 다를 것이고, 이 글은 나의 한정된 경험에만 초점이 맞춰져 있기 때문이다. 다만 어쩔 수 없이 풀스택을 해야만 하는 상황이 올 수도 있을텐데, 그런 상황이 무조건 꺼릴 일만은 아니라고 말하고 싶었다. 또한 다른 직무를 경험하고 싶지만 머뭇거리는 사람이 있다면 나처럼 긍정적인 케이스도 있다고 말하고 싶었다. 어설픈 지식의 저주저도 여러 가지를 해야 이해의 폭이 넓어져서 추천을 하지만, 한국 한정으로는 이직 할 때 어려운 지점이 있긴 합니다. Software Engineer 경력 N년차가 아닌, 다들 특정 포지션으로 경력 N년 이상으로 해서 올리는 채용 공고가 많아서요.햄햄님은 어떤 언어를 가지고 풀스택 개발을 하고계신가요?오호 글 잘 보고 있습니다😎
궁금한 점이 있어요!
풀스택으로 일하게되면 프론트랑 백엔드 중 어느 업무를 중심으로 하나요?
회사마다 다른가여저도 후회하는것 중 하나가 신입때 너무 프론트에만 한정지어서 공부했다는게 아쉬웠습니다. 서비스 개발을 위해서는 반쪽인 개발자밖에 되지않는게 너무 아쉬웠어요
할줄 아는 언어라고는 js(ts) 뿐이라서 nest로 요새 백앤드 살짝씩 해보는데 백앤드도 어렵네요 ㅠ 흠 현재 회사에서 잡부로 일하고 있는데 어찌보면 장점일 수 있겠네요",https://velog.io/@hyemin916/%EC%A3%BC%EB%8B%88%EC%96%B4%EC%9D%BC-%EB%95%8C-%ED%92%80%EC%8A%A4%ED%83%9D%EC%9D%84-%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%9D%B4%EC%9C%A0
React로 멋진  3D 은하 만들기(feat. R3F),minboykim.log,https://velog.velcdn.com/images/minboykim/post/7208e664-7acb-4c29-9aff-f6ea944a3b9f/image.gif,"React로 멋진  3D 은하 만들기(feat. R3F)별글 프로젝트서론🌟 별 하나에 글 하나 프로젝트이번 글에서는 프로젝트의 시작인 은하 만들기를 시도한 과정을 설명하겠다. 이 과정은 두 명의 팀원 분들과의 페어프로그래밍으로 진행했다.팀원들의 블로그 링크
https://velog.io/@greencloud
https://velog.io/@200tiger목표R3F 라이브러리를 활용해서 위처럼 멋진 3D 은하를 만들어보자. 이 글에서는 R3F 설치를 비롯한 너무 기초적인 설명은 제외하겠다. 구글에 좋은 자료들이 많으니 따라서 설치하고 간단하게 배워보자.준비본격적으로 은하를 만들기 전에 기본적인 세팅을 진행하고, 필요한 수학적 지식을 이야기해보자. 필자도 수학을 잘하진 않으니 너무 걱정할 필요는 없다.기본 세팅먼저 R3F에서 사용할 수 있는 유용한 함수들과 컴포넌트들이 존재하는 drei 패키지를 설치해주자.
yarn add @react-three/drei
이후 Vite 또는 CRA 등 원하는 방식으로 프로젝트를 생성하고, 필요없는 파일들을 모두 정리한 뒤 App.tsx를 다음과 같이 작성하자.개발 서버를 실행했을 때 다음과 같은 결과가 나오면 성공이다. 마우스를 이용해 화면을 돌리거나 확대/축소해보자.간단한 설명을 하자면, Canvas 컴포넌트로 3D 오브젝트들을 렌더링할 공간을 만들어주고, color 태그를 활용해 배경색을 지정, ambientLight로 광원을 지정해주었다.
axesHelper는 화면에 보이는 빨간색 x축, 초록색 y축, 파란색 z축을 표시해준다. OrbitControls를 포함시켜주는 것으로 드래그 및 마우스 휠로 시점 변경, 확대/축소를 할 수 있다.R3F에서 오브젝트를 생성하는 방법
R3F에서는 geometry를 통해 오브젝트의 모양을, material을 통해 오브젝트의 재질을 정의한다. 정말 다양한 geometry와 material들이 존재하므로 원하는 것을 선택해 mesh로 감싸주고 Canvas안에 위치시키면 오브젝트가 생성된다. 각각의 자세한 모양 및 재질, 속성들에 대해서는 구글링이나 R3F 공식문서, drei 공식문서를 참고하자.랜덤 모듈편한 개발을 위해 정수 난수 생성 함수, 실수 난수 생성 함수가 필요하다. utils/random.ts파일을 생성해 두 함수를 넣어두고 필요할 때 import 해오자. 정수 난수 생성 함수와 실수 난수 생성 함수는 간단하게 구현하였으므로 추가적인 설명은 하지 않겠다.우선은 이정도만 준비해두고 이제 구현을 시작해보자.별 컴포넌트배경별과 은하 구성에 사용될 별 오브젝트를 만들어보자. 코드는 다음과 같다.별의 모양은 구이므로 sphereGeometry를 선택했고, 재질은 기본적인 재질인 meshStandardMaterial을 이용했다. 컴포넌트를 이용할 때 position과 size에 대한 정보를 props로 받아 위치와 크기를 지정한다. 색깔은 아무 색깔이나 임의로 설정해주었다. 원하는 색깔로 지정해보자.이렇게 끝낼 수도 있지만, 사용자가 마우스 휠로 화면을 축소했을때, 별의 크기가 너무 줄어들면 별로 예쁘지 않다. 따라서 줄어드는 최소 크기를 설정하는 것이 좋은데, R3F의 useRef와 useFrame 훅을 이용하면 구현할 수 있다. 또한 별이 가만히 있으면 심심하므로 공전도 시켜보자.useFrame 훅에 대해 짧게 설명하자면 매 프레임마다 수행될 콜백함수 하나를 인자로 받고, 해당 콜백함수에는 현재 어플리케이션의 상태를 나타내는 state 객체와 직전 프레임과 현재 프레임 사이의 간격인 delta 가 주어진다. 이를 활용해 오브젝트들의 상태를 업데이트하거나 애니메이션을 구현할 수 있다.먼저 useRef 훅을 통해 메쉬에 대한 접근을 얻어오자.이제 meshRef를 통해 메쉬에 접근할 수 있다. 이를 활용해 useFrame 훅을 구성해보자.먼저 meshRef.current.position.applyAxisAngle(Y_AXIS, delta / 100) 을 통해 공전을 구현해줬다. meshRef.current.position 을 통해 현재 메쉬의 위치 정보를 벡터의 형태로 가져오고, apllyAxisAngle 메소드를 통해 벡터를 회전시킬 수 있다. applyAxisAngle 메소드는 회전시킬 기준 벡터와 각도를 인자로 받는데, 자전을 구현하기 위해 기준 벡터는 Y축 ([0, 1, 0] 벡터)로 지정해줬고, 회전의 각도는 프레임의 간격 / 100 정도로 지정해줬다. 회전의 각도를 늘리면 빠르게 회전하고, 회전의 각도를 줄이면 느리게 회전하므로 원하는 값으로 조정 후 meshRef.current.position 의 x, y, z값을 계산된 pos의 값들로 변경해주자. meshRef.current.position 자체는 read-only 이므로 하나씩 넣어주어야한다.다음으로 최소 크기를 제한하는 부분을 설명하자면, 간단히 DIST_LIMIT 으로 선언된 일정 범위만큼 카메라가 멀어지면 meshRef.current.scale의 값을 비율만큼 조정해 더이상 작아지지 않게 구현해주었다. 카메라로부터 메쉬까지의 거리는 state.camera.position을 통해 카메라의 위치에 접근할 수 있고, distanceTo메서드를 통해 meshRef.current.position 까지의 거리를 얻어올 수 있다.결과를 미리 조금 스포일러해보자면,
이것이 최소 크기를 제한하지 않았을 때의 은하 모습이고

이것이 최소 크기를 제한했을 때의 은하 모습이다. 멀리서 봤을 때 그 차이가 잘 드러난다.최종적으로 Star 컴포넌트의 코드는 다음과 같다.배경별 만들기이제 별 컴포넌트가 준비되었으므로, 배경별부터 생성해보자. 배경별은 정말 간단하게 위에서 만든 별 컴포넌트를 우주공간에 랜덤하게 배치해주기만 하면된다.
배경별들을 생성하는 함수는 다음과 같다.함수의 내용 그대로 size는 15~20중 랜덤으로, position은 50000크기의 공간 상에 랜덤으로 배치되도록 해주었다. for문으로 500개의 별을 생성하고 하나의 배열로 리턴하는 모습이다.리턴받은 배열을 App.tsx의 캔버스에 위치시켜주자.실행시켜보면 배경별이 멋지게 나오는 모습을 확인할 수 있다.은하 만들기이제 주인공인 은하를 만들어보자. 조금 어려울 수도 있지만 천천히 따라가면 할 만 하다.정규 분포은하는 중심에 별이 많이 존재하므로 은하를 구성하는 별의 위치를 특정하기 위해 정규분포를 활용해야하는데, 배운지 너무 오래되어서 기억이 잘 나지 않는 사람들을 위해(사실 필자다) 간단히 짚고 넘어가자.
이미지 출처 - Khan Academy정규분포 또는 가우스 분포라고도 하는 이 확률분포는 평균을 기준으로 종모양으로 대칭이며, 평균값과 표준편차로 그 모양이 정해진다. 우리는 이 정규분포를 활용하여 랜덤한 값을 리턴해주는 gaussianRandom 함수를 구현해 별들의 위치를 계산할 것이다. 함수의 모습을 먼저 확인해보자.평균값과 표준편차를 인자로 받아, 정규분포를 구성하고 해당 정규분포를 따르는 랜덤한 값을 리턴해주는 함수이다. 정규분포를 따르는 랜덤한 값이란, 난수가 해당 정규분포의 모양대로 평균값이 나올 확률이 가장 높고, 평균값을 기준으로 멀어진 값일 수록 나올 확률이 대칭적으로 점점 감소한다는 뜻이다.
함수의 자세한 수식은 Box muller변환이라는 방식을 사용하는데, 가장 간단하게 정규분포 난수를 생성할 수 있는 방법이다.

이미지 출처 - 위키백과
이러한 수식이라고하는데, 수학 관련 포스트는 아니므로 자세한 것은 위키백과를 확인해보자. 우리에게 중요한 것은 이제 정규분포를 따르는 난수를 생성할 수 있다는 것이다. 위 함수를 utils/random.ts 파일에 위치시켜주자.나선 좌표 구하기은하의 모양을 만들기 위해, 나선 좌표를 구하는 함수를 구현해야한다. 이 함수는 인자로 원래 x, y, z 좌표와 나선의 시작각도를 받아 꼬아진 나선에서의 좌표를 리턴할 것이다. 함수의 모습은 다음과 같다.어려워 보이지만 하나씩 천천히 살펴보자.
const r = Math.sqrt(x ** 2 + z ** 2);
이 라인은 원점으로부터 좌표의 xz평면상의 위치까지의 거리, 반지름 r을 거리공식

을 이용해 계산한 것이다.이후 theta를 이용해 나선의 꼬인 각도를 계산한다. 먼저 시작각도인 offset을 이용해 초기화 해준다.
theta += x > 0 ? Math.atan(z / x) : Math.atan(z / x) + Math.PI;
이 라인은 각도를 보정하는 라인으로, Math.atan 을 이용해 좌표 (x, z)의 각도를 계산하여 나선 모양의 각도를 계산한다.다음으로 theta += (r / ARM_X_DIST) * SPIRAL; 이 라인은 나선의 꼬임정도를 계산하여 각도를 보정하는 라인으로, ARM_X_DIST는 x좌표의 표준편차를, SPIRAL은 나선의 꼬임 정도를 의미한다.이후 계산된 각도값 theta와 반지름 r값으로 이루어진 극좌표값을 직교 좌표값으로 변환하기 위해 각각 Math.cos와 Math.sin을 이용해준다.이제 이 함수를 이용하여 은하를 구성해보자.먼저 사용되는 상수들부터 설명하겠다.
ARMS: 나선팔의 개수
NUM_STARS: 은하를 구성하는 별의 총 개수
ARM_X_MEAN: x좌표 정규분포의 평균값
ARM_X_DIST: x좌표 정규분포의 표준편차
ARM_Z_MEAN: z좌표 정규분포의 평균값
ARM_Z_DIST: z좌표 정규분포의 표준편차
STAR_MIN_SIZE: 별의 최소 크기
STAR_MAX_SIZE: 별의 최대 크기
GALAXY_THICKNESS: 은하의 굵기(y좌표의 최대값)흐름은 다음과 같다.
나선팔의 개수만큼 반복문을 순회하며 각 나선팔을 구성한다. 각 나선팔은 나선팔에 배정되는 별의 개수(NUM_STARS / ARMS)만큼 반복문을 순회하며 각 별을 구성한다.별의 size는 간단하게 최소 크기와 최대 크기 사이의 값을 랜덤으로 부여하고, 위치 벡터는 위에서 구현한 spiral함수를 통해 계산한다.
초기의 좌표값은 각 상수값을 활용한 정규분포 난수를 통해 생성한다. 각도 초기값 offset은 arm * 2 * Math.PI를 나선팔의 개수ARMS 로 나눠주어 각 나선팔의 시작 각도를 계산해준다.완성된 은하 컴포넌트를 캔버스에 위치시키면 멋진 은하를 만나볼 수 있다!은하 컴포넌트의 전체 코드는 다음과 같다.수식이 너무 어렵다면수식이 너무 난해하여 이해하기 어렵다면,leva 라는 패키지의 도움을 받아 각 값들을 조정해보며 결과를 확인하면 꼭 100% 이해하지 않더라도 사용할 수 있다. 그 방법을 알아보자.먼저 yarn add leva -D 커맨드를 통해 패키지를 설치해주자. leva 패키지는 useControls 라는 훅을 제공하는데, 이를 활용해 실행화면에서 GUI로 원하는 값들을 조정하며 결과를 바로바로 확인해볼 수 있다. 위에서 사용했던 상수들을 useControls 훅을 이용해 조정하고 확인해보자.이와 같이 useControls 훅의 인자로 값들의 이름과 초기값을 객체로 넘긴 뒤, 구조분해할당을 이용해 가져와서 사용하면 된다. 실행 결과를 확인해보면사진처럼 우측 상단에 값을 조정할 수 있는 컨트롤 박스가 생성되어 키보드로 값을 입력할 수 있다. 값을 변경하면 즉시 화면에 반영되므로 결과를 확인하며 값에 대한 의미를 파악하기에 좋다. 이를 활용해 수식에 대한 완벽한 이해없이도 각 값들이 의미하는 바와 어떤식으로 조절해야 원하는 모양을 만들어낼 수 있을지 확인할 수 있다.leva 를 활용한 은하의 전체코드는 다음과 같다.결론이번 글에서는 R3F를 활용해 3D로 은하를 만들어보았다. 수학 수식이 많이 들어가고 처음 접해보는 3D 개발이라 익숙하지 않은 부분들이 많았지만, 하나하나 따라가다보면 멋진 결과물을 만들 수 있어 좋은 경험이었던 것 같다. 이제 이 은하를 조금씩 발전시켜나가 프로젝트를 성공적으로 마무리 할 수 있기를 바란다.잘못된 정보나 궁금한점이 있다면 댓글 남겨주세요!Refereces
정규분포 Khan Academy
Box Muller transform 위키백과
R3F 공식 문서Vite, 왜 쓰는거지?멋지네요^^ 붐업드립니다",https://velog.io/@minboykim/React%EB%A1%9C-%EB%A9%8B%EC%A7%84-3D-%EC%9D%80%ED%95%98-%EB%A7%8C%EB%93%A4%EA%B8%B0feat.-R3F
Java 개발자의 Kotlin 기본 문법 정복기,기록은 기억을 이긴다 🌱,https://velog.velcdn.com/images/joshuara7235/post/bd4eca9b-cbc3-4964-aca9-70877733ced7/image.jpeg,"Java 개발자의 Kotlin 기본 문법 정복기Kotlin 정복기🌱 서론원하던 회사에 이직을 했다. 야호! ✈️
(여담이지만 이직을 준비하면서, 그리고 이직한 회사에서 얻은 인사이트를 정리하여 조만간 블로그에 올릴 예정이다.)이직한 회사는 현재 Java로 만들어진 레거시 코드들을 Kotlin 으로 전환하는 중이다.
이미 서비스가 굴러가고 있는 터라 달리는 자동차의 바퀴를 바꾸는 과정에 있다.안그래도 Kotlin 을 배우고 싶었는데,
Kotlin 보다 아직 더 우선적으로 공부할 것들이 많아서 뒤로 미루고있었다. (게을러서다)입사하고 코드들을 봤는데 일단 Kotlin 이었다. 👀
들어보니 인텔리제이의 도움을 받아 Java 코드들이 일단 Kotlin 으로 돌아는 가게끔 만들었다고 했다.이제 이 코드들을 Kotlin 스럽고 '우아하게' 만들어야 한다. 🍬코드들을 들여다보는데 역시나 익숙하지 않아서인지 한눈에 들어오지 않았다.Kotlin 을 공부한다면 꼭 들어야겠다고 벼르고 있었던 '인프런' 의 '최태현' 님의 강좌를 새로운 회사에 출근한지 일주일만에 신청했다. (교육 복지 만세 🎉)강의 링크 : 👉🏻 자바 개발자를 위한 코틀린 입문
(어떠한 광고비도 받지 않았다 ㅎ.. 강의가 너무 좋았음 👍🏻)퇴근 후 그리고 주말을 이용해 일주일만에 기초강의를 들었다.
그만큼 강의가 재미있었고, 배우는 즐거움이 컸다.강의를 들은 후, 이 포스팅을 적기 시작했다.
포스팅을 정리하는 것도 약 일주일이 걸렸다. 🥳이 포스팅의 목적은 다음과 같다.목적
1. 강의에서 배운 내용을 바탕으로 복습겸 Kotlin 문법을 정리한다.
2. Java 에 익숙한 개발자들이 이해하기 편하도록 정리한다.
3. 실무에서 문법이 헷갈리거나 개념이 헷갈릴 때 언제든 찾아 볼 수 있도록 기초 문법 사전으로 사용하도록 정리한다.📖 강의 정리ITEM 1. 변수모든 변수는 우선 val 로 선언하는 것을 추천한다.
꼭 필요한 경우. 즉, 값이 변해야 하는 경우에만 var 로 선언한다.💡 Key Point
1. val : value 값 자체를 의미한다. 변하지 않는다.
2. var : variable 변할 수 있는 값 즉, 변수를 의미한다.💡 Key Point
1. 코틀린에서는 Primitive Type 과 Reference Type 차이가 없다.
2. 자바의 Reference Type 은 null 이 들어갈 수 있으므로 Kotlin 에서는 타입에 ? 를 붙여주었다.
- null 은 다음 챕터에서 더 다뤄보자.💡 Key Point
1. 코틀린에서는 객체를 인스턴스화 할 때 new 를 사용하지 않는다.
- 개인적으로는 이게 아직 어색하더라 .. new 쓰고 다시 지우곤 한다 ㅎITEM 2. nullSafe Call 과 Elvis 연산자말 그대로 안전하게 불러오는 것을 의미함?. 을 통해 null 이 들어올 수 있는 값이 npe 터지지 않도록 함.null 이라면 null 그대로를 반환한다.앞의 연산 결과가 null 이면 Elvis 연산자 뒤의 값을 사용한다.?: 형태왜 Elvis 냐? 저걸 시계방향으로 돌리면 꼬브랑 머리가 엘비스 프레슬리 같다고 ..ㅎ..Safe Call 과 Elvis 연산자를 활용하여 Java -> Kotlin직관적이면서도 간결하다. 만세 ! null 을 안전하게 다루는 Kotlinstr 이 String 타입이므로 (String? 타입이 아니므로) null 이 들어가지 않는다고 코틀린이 간주한다.그러므로 startsWith() 메서드 콜이 바로 가능하다.str 은 String? 타입이므로 null 이 들어갈 수 있다.이 경우 메서드 콜을 위해 safe call 을 한다.str?.length 는 str 이 null 이 아니면 실행하고, null 이면 실행자체를 하지 않고 null 을 반환한다.💡 Key Point
1. 코틀린은 null 이 가능한 타입(?가 붙은 타입)을 다른 타입으로 취급한다.
2. 언어 단에서 null 을 안전하게 다뤄준다는 것만으로도 코틀린을 써야할 이유가 충분하다. ㅎ..nullable 이지만, 절대 null 일 수 없는 경우이런 경우는 어떤 경우일까? 🤔DB 에 처음 데이터가 들어올 때는 null 일 수 있어서 nullable 이지만,
한번 어떠한 비지니스 로직을 통해 해당 데이터가 업데이트 되면 그 이후로는 절대 null 이 아닌 경우절대 null 이 아니야!! 그러니까 startWith() 메서드를 실행해줘!!!!💡 Key Point
1. 절대 null 이 아니다!! 라고 소리친다고 이해하면 좋음
2. 개인적으로는 이 방법이 썩 좋은 방법 같지는 않다. (어떤일이 터질지 모르니까.. 프로그래밍 세계는 절대적인게 없거든. 웬만하면 안써야겠다.)ITEM 3. Type타입 캐스팅과 (개쩌는) 스마트 캐스팅version 1instanceof 는 is 로 사용된다.java 에서 캐스팅을 위한 (Person) 은 as 를 사용하며, 생략이 가능하다.version 2개쩌는 스마트 캐스팅 🫢코틀린이 if 절을 컴파일에서 이미 이해하고, obj 가 Person 타입인것을 인지하여 age 메서드 콜이 가능하다.version 3안전한 캐스팅Person 에 null 이 들어올 수 있을 때, nullable 로 선언이 가능하다.이 타입이 아닌경우에도 castException 이 아니라 null 이 반환된다.💡 Key Point
1. instanceof -> is
2. 캐스팅은 as 로 사용하며, 생략이 가능.
3. 코틀린은 스마트 캐스팅이 가능하다.Kotlin 의 특이한 타입 3가지Java 의 Object 역할. 즉, 모든 객체의 최상위 타입Any 자체로는 null 을 포함하지 않는다.
- null 포함하려면 Any? 로 표현해야한다. ㅎAny 에 equals, hashCode, toString 이 존재한다Java 의 void 와 동일한 역할하나 다른 점은, unit 은 그 자체로 타입 인자로 사용 가능하다.이게 무슨말이냐면 코틀린의 unit 은 실제 존재하는 타입이라는 것! (Java 의 void 는 타입이 없었..)함수가 정상적으로 끝나지 않았다는 사실을 표현할 때 쓰인다.'무조건 예외를 반환하는 함수', '무한루프 함수' 등..실무에서는 잘 안쓰인다.ITEM 4. 연산자연산자 공부를 위해 만들어진 Money 클래스💡 Key Point
1. 위랑 아래 코드 진짜 똑같은 코드가 맞다. 놀라울따름 ㅎ..
2. 해당 내용은 클래스 부분에서 다시 더 자세하게 다루겠다.비교 연산자객체를 비교할 때, 비교연산자 (>,<, >=, <=) 를 사용하면 자동으로 compareTo 를 호출한다.코틀린은 클래스를 생성할 때 자동으로 compareTo 메서드를 만들어 주기 때문에 위의 코드에서 보이지 않는다.동등성과 동일성동등성 : '두 객체의 값이 같은가'Java : equals() 로 비교Kotlin : == 로 비교동일성 : '완전히 동일한 객체인가' 즉, '주소' 값이 같은가Java : == 로 비교Kotlin : === 로 비교money1 와 money3 은 주소 값이 같은 동일한 객체다. (==)compareTo() 가 구현되어 있다면, money1 과 money4 는 equals() 즉, 값이 같은 동등한 객체다좀 헷갈림..보다 직관적이다.= 이 하나 더 붙으면 '주소까지 같은지 완전 비교하자!' 라는 의미로 이해하면 좋다.연산자 오버로딩코틀린에서는 객체마다 연산자를 직접 정의할 수 있다.operator 키워드를 통해 가능하다.위에도 써놓은 Money 클래스다.operator 키워드를 통해 연산자를 직접 정의했다.이 부분도 매우 신기한데, 정해진 연산자 네이밍 메서드를 마음대로 커스텀하여 만들 수 있다.plus 라는 연산자를 오버로딩 하면, + 로 객체끼리 연산을 하게 되면 정의한 대로 연산이 된다. 개.쩐.다 🫢💡 Key Point
1. operator 연산자를 정해진 연산자 메서드 네이밍에 맞춰 커스텀할 수 있다.
2. 사용할 때, 해당 연산자를 사용하면 오버로딩된 연산이 가능하다. (+ -> plus)ITEM 5. 제어문if위의 코드는 사실 별다를게 없다.if-else Statement vs Expression Statement : 프로그램의 문장. 하나의 값으로 도출되지 않는다. 즉, return 값으로 사용 불가.Expression : 하나의 값으로 도출되는 문장. (Java 에서는 3항 연산자 같은 것)💡 Key Point
1. 코틀린에서 if-else 문은 Expression 이다.
2. 코틀린에서는 if-else 가 Expression 이므로 3항연산자가 없다. 사실 쓸 필요가 없음..ㅎ 코틀린에서는 if-else 가 Expression 이므로 변수로도 할당이 가능하다. 🫢when (switch 보다 강력한..!)코틀린에서는 switch 가 사라지고 when 이 생겼다.when 역시 Expression 이다. default 대신 else 를 사용한다.when 을 사용하면 어떠한 범위에 있거나 다른 기타 조건을 사용해서 분기를 치는 것도 가능하다.즉, '조건부' 를 사용할 수 있다는 것.이 조건부에는 어떠한 Expression 도 들어갈 수 있다. 매우 강력하다.위와 같이 조건부에 is 를 사용할 수 있다.또한, 스마트 캐스팅이 되므로 바로 메서드 콜이 가능하다. 개쩐다.. 🫢조건부에 여러가지 조건을 함께 사용할 수 있다.함께 조건 , 로 들어간다면 or 의 의미다.when 절에 값을 넘기지 않고 바로 조건부에 조건문을 넣을 수 있다.ITEM 6. 반복문전통적인 for 문💡 Key Point
1. 코틀린에서는 range 를 .. 으로 나타낸다.
2. 코틀린에서 downTo 와 step 은 '중위함수' 인데, 아래의 '함수' 파트에서 더 자세하게 다룬다.향상된 for 문💡 Key Point
1. 코틀린에서는 : 대신 in 을 사용한다.while💡 Key Point
1. while 은 자바와 코틀린 동일하다.ITEM 7. 예외try - catch - finally💡 Key Point
1. 구조는 문법적으로 완전히 똑같다.
2. 깨알 팁 : 코틀린에서의 형변환은 변환할변수.to타입() 형태의 메서드로 이루어진다.💡 Key Point
1. null 이 반환 될 수 있는 경우 코틀린에서는 반환타입을 신경써야 한다. ? 를 꼭 잊지말기
2. 코틀린에서는 try - catch 문도 Expression 이다. Checked Exception 과 Unchecked Exception💡 Key Point
1. 코틀린에서는 모두 Unchecked Exception 이다.
2. 즉, IOException 등의 Checked Exception 을 코드를 짤 때 신경 써줄 필요가 없다. 🫢try with resourcesjdk 7에서 추가 됨.외부 리소스를 try 문 안에서 생성하고 자동으로 close 해주는 것!💡 Key Point
1. 코틀린에서는 try with resources 구문이 없다.
2. 대신 use 라는 inline 확장함수를 사용한다. 아래에 함수 부분에서 자세하게 정리되어있다. ITEM 8. 함수바디{} 가 필요없다면 굳이?💡 Key Point
1. 함수 자체의 결과값이 하나라면 결과값을 = 을 통해 바로 넣어 줄 수 있다.
2. 파라미터가 모두 Int 이므로, 함수의 반환타입이 Int 라는 것을 타입추론을 통해 알수 있으므로 이 함수의 반환 타입은 생략 가능하다.🫢
3. 만약 중괄호를 사용했다면 명시적으로 반환타입을 적는 것이 좋다.Default Parameterrepeat 함수가 3개. 오버로딩이 되어있다.이유는 useNewLine 이 true 로 사용되는 경우가 많아서!그런데 또 쓰다보니까 num 이 3 인 경우도 꽤 많아서 또 오버로딩을 했다.흠.. 그런데 이렇게되면 계속 오버로딩을 하게 되는데...  코틀린에서는 Default Parameter 라는 개념이 존재한다. 🫢값을 넣지 않으면 기본 값을 주어주는 것이다.Named Argumentrepeat 함수에서 값을 넣지 않으면 기본값을 사용하고, 임의로 값을 넣어주고 싶다면 골라서 파라미터의 이름을 key 로 넣고 값을 줄 수 있다.이건 정말 아름답고 개쩐다고 말할 수 밖에 없다.🍬어떤 값은 default parameter 에 맡기고, 변경되는 값만 쏙 넣어줄 수 있는 것 🫢builder 를 만들지 않고 builder 의 장점을 그대로 가져 올 수 있다.동일한 타입의 parameter 가 있을 경우에도 named argument 는 매우 큰 장점을 가진다.builder 를 사용할 때 이런 것을 확인하기 쉽다는 장점이 있는데, 이와 같은 장점을 누릴 수 있다. 가변인자💡 Key Point
1. Java : ... 을 사용
2. Kotlin : vararg 를 사용💡 Key Point
1. 스프레드 연산자 : * 배열안에 있는 것들을 마치 그냥 ',' 쓰는 것처럼 요소들을 펼쳐서 꺼내준다.ITEM 9. 클래스클래스의 선언💡 Key Point
1. val 은 불변이므로 java의 final 이 붙은 것과 같다.
또한, final 은 수정될 수 없으므로 getter 만을 생성한다.
2. age 는 var 로 선언되었으므로, getter 와 setter 모두 생성해준다.
3. 코틀린에서는 필드선언과 생성자를 동시에 선언한다.위와 같은 방법으로 값을 초기화 할 수 있다.초기화 블록💡 Key Point
1. init 을 통해 초기화 블록을 만들 수 있다.
2. 객체가 생성되었을 때 해당 로직이 실행 된다.Custom Getter예시 1>예시 2>💡 Key Point
1. Person 클래스에 upperCaseName 이라는 필드가 있는 것처럼 사용할 수 있다.
2. getter 를 사용 하는 것처럼 객체에서 바로 필드 이름으로 접근이 가능하다. 🫢
3. isAdult 또한 마찬가지 ! ITEM 10. 상속추상클래스 상속💡 Key Point
1. 코틀린에서 상속은 extends 대신에 : 를 사용한다.
2. 상속받은 상위 클래스의 생성자를 반드시 바로 호출해야한다.
3. 코틀린은 @Override 어노테이션이 없다. 대신 override 라는 키워드를 '필수적'으로 붙여줘야 한다.💡 Key Point
1. legCount 를 override 하기 위해서는 Animal 의 legCount 를 open 해줘야 한다.추상 프로퍼티가 아니면, 상속받을 때 open 을 꼭 붙여야 한다. 추상 클래스에서 자동으로 만들어진 getter 를 override 하기 위함이다. 인터페이스 구현💡 Key Point
1. 코틀린에서는 인터페이스의 구현도 : 을 사용한다.
2. super 의 위치가 다르다. super<타입>.함수💡 Key Point
1. 코틀린 인터페이스의 프로퍼티는 디폴트 값을 가질 수 있다. -> flyAbility 는 10의 값을 가진다.
2. Swimable 인터페이스의 swimAbilty 프로퍼티는 디폴트 값이 없으므로 구현할 때 getter 를 override 하여 구현해줘야 한다.
3. Flyable 인터페이스의 flyAbility 프로퍼티는 디폴트 값이 있으므로 구현하지 않아도 된다.하지만 디폴트 값이 아닌 다른 값을 넣고 싶다면 override 할 수 있다.추상클래스도 아니고 인터페이스도 아닌 일반 클래스를 상속받을 때 주의할 점💡 Key Point
1. 일반 클래스를 상속 하려면, 상위 클래스는 open 이라는 키워드로 열려있어야 한다. 그래야 상속이 가능하다.
2. 상위 클래스에서 생성자 혹은 초기화 블록에 사용되는 프로퍼티에는 open 을 피해야한다.현재 Base 클래스의 number 프로퍼티는 open 으로 열려있다.Derived 는 number 를 override 하고 있다.main 함수에서 Derived(300) 으로 객체를 생성하면 Base 초기화 블록에서는 number 가 뭐라고 나올까?0 이 나오게 된다.Derived 를 호출할 때, Base 클래스를 먼저 호출을 하는데, 이 시점에서는 number 가 아직 주입되지 않았기 때문이다. 100이 나오지도 않는다. 왜냐하면 override 했기 때문에, 주입된 값을 받으려고 하기 때문이다.그러므로 상위 클래스의 생성자 혹은 초기화 블록의 프로퍼티는 open 으로 열어 두지 말자!위와 같이 되어야 정상적으로 Derived(300) 을 호출 했을 때, Base 클래스 생성시 300이 출력된다.ITEM 11. 접근 제어유틸성 함수를 만들 때💡 Key Point
1. 코틀린에서는 유틸성 함수를 만들 때 클래스 생성할 필요 없이 파일 최상단에 만들면 편하다.구성요소의 접근 제어💡 Key Point
1. name 은 getter 의 접근제어자가 internal 이다. (val 이므로 getter뿐이다)
2. owner 는 getter 와 setter 모두 private 이다.
3. price 는 getter 는 public 이며, setter 는 명시적으로 private 이 되었다.코틀린에서는 기본 접근제어자가 public 이다.ITEM 12. object 키워드static 함수와 변수💡 Key Point
1. 코틀린에서는 static 이 없다.
2. companion object 를 대신 사용한다.이 블럭안에 넣어둔 변수와 함수가 static 변수와 함수가 된다.  static : 클래스가 인스턴스화 될 때 새로운 값이 복제되지 않고, 정적으로 인스턴스끼리의 값을 공유한다.companion object :
- 클래스와 동행하는 유일한 오브젝트.
이것도 클래스라는 설게도와 동행하는 유일한 오브젝트로 정적이다.
이것도 클래스라는 설게도와 동행하는 유일한 오브젝트로 정적이다.한 클래스에는 하나의 companion object 를 만들 수 있다.companion object 에 유틸성 함수를 넣어도 되지만, 유틸 함수는 최상단 파일을 활용하는 것이 좋다.💡 Key Point
1. companion object 는하나의 '객체'로 간주된다.그렇기 때문에, 이름을 붙일 수 있고, interface 를 구현할 수도 있다.위의 companion object 는 Factory 라는 이름을 가지며, Log 인터페이스를 구현한다.Log 인터페이스의 log() 함수를 override 를 통해 구현한다. 💡 Key Point
1. val : '런타임' 시에 변수가 할당된다.
2. const val : '컴파일' 시에 변수가 할당된다.const 는 진짜 상수에 붙이기 위한 용도다. const 없이 그냥 val 만 사용하면 런타임 때 변수가 할당 된다. (물론 val 은 final 이므로 런타임시에 최초 할당 이후로 변경 불가)기본 타입과 String 에도 붙일 수 있다.Singleton이게 끝임..! 익명 클래스💡 Key Point
1. 코틀린에서의 익명클래스는 문법이 조금 다르다.Java : `new 타입이름() { ... }Kotlin : `object : 타입이름 { ... } override 키워드를 통해 인터페이스의 메서드를 익명클래스로 구현한다.ITEM 13. 중첩 클래스Inner 클래스와 static inner 클래스
Inner 클래스 : 바깥 클래스를 참조하고 있다.
Inner 클래스 : 바깥 클래스를 참조하고 있다.
static inner 클래스 : 바깥 클래스를 호출 할 수 없다.
static inner 클래스 : 바깥 클래스를 호출 할 수 없다.static inner 클래스를 사용하자!static 을 사용하지 않은 Inner 클래스는 숨겨진 외부 클래스 정보를 가지고 있기때문에 참조를 끊어주지 못할 경우 메모리 누수가 생긴다.이런 경우 디버깅도 어렵다.내부 클래스 직렬화 형태가 명확히 정의 되지 않아서 직렬화에 있어 제한이 있다.클래스 내부에 클래스를 만들 때는 static 클래스를 사용하라Effective Java💡 Key Point
1. 코틀린은 권장되지 않는 Inner class 를 만드는 것을 번거롭게 했다.inner 라는 키워드를 굳이!! 써줘야 한다.즉 바깥 클래스를 참조하는 (Anti pattern) 클래스를 만들기 위해서 굳이 inner 키워드를 써야한다.바깥 클래스를 참조하여 값을 가져오려면 굳이 this@바깥클래스.값 의 형태로 가져와야 한다. (this@House.address)코틀린은 class 내부에 class 를 만들면 권장되는 static inner class 가 된다.그냥 편하게 내부에 class를 만들어 주면된다.기본적으로 바깥 클래스에 대한 참조가 없는 클래스가 만들어진다. ITEM 14. 다양한 클래스 (Data, Enum, Sealed)📀 Data ClassDTO (Data Transfer Object)Data Class 는 주로 DTO 로 사용된다.계층간의 데이터를 전달하기 위한 클래스를 의미한다. 💡 Key Point
1. 'That's ENOUGH' : data 만 class 앞에 적어두면 dto 클래스로서 완벽하다.equals(), hashCode(), toString() 을 자동으로 만들어 준다. 여기에 named argument 까지 활용한다면, builder 패턴을 사용하는 것과 같은 효과도 가진다.사실상 data 키워드에 builder 까지 있는 격이다. Enum ClassEnum 추가적인 클래스를 상속받을 수 없다.인터페이스는 구현할 수 있다.각 값들은 싱글톤이다. 💡 Key Point
1. enum 은 java 와 kotlin 은 큰 차이는 없다.
2. 사용에 있어서 진가를 발휘하는데, kotlin 의 when 문법에서 진가를 발휘한다. handleCountry 함수를 보자.when 과 enum 을 활용하면 더 읽기 쉬운 코드를 사용할 수 있다.컴파일러가 Country 의 모든 타입을 알고 있어서 else 를 추가로 작성할 필요가 없다. 코딩을 하면서 enum 클래스에 변화가 있으면 컴파일러에서 경고를 바로 날려서 개발자에게 알려준다.🫢 개쩐다!
- '님 뭐 잊은거 없음? Enum 에 France 추가 되었음!' 이라고 알려줌 👍🏻java 에서는 enum 클래스에 값이 추가되어도 알 방법이 없다.Sealed Class, Sealed Interface Sealed : 봉인된 상속이 가능하도록 추상클래스를 만들었지만, 외부에서는 이 클래스를 상속받지 못하게 '봉인' 하는 것컴파일 타임 때 하위 클래스 타입을 모두 기억한다.
- 즉, 런타임 때 클래스 타입이 추가될 수 '없다'하위 클래스는 같은 패키지에 있어야 한다.💡 Key Point
1. Enum 과 차이클래스를 상속받을 수 '있다.'하위 클래스는 멀티 인스턴스가 가능하다.Enum 과 마찬가지로 when 에서 매우 효과적으로 사용이 가능하다.추상화가 필요한 Entity 나 DTO 에 활용된다. ITEM 15. 배열과 컬렉션배열배열은 잘 사용되지 않는다.하지만 기본 문법은 알아두잣!💡 Key Point
1. 배열의 선언arrayOf() 를 통해 선언해준다.배열의 범위 - indices0 부터 마지막 index 까지의 범위를 의미한다.indeces 는 index 의 복수형이다. 인덱스와 값을 동시에 가져오기 - `withIndex()배열의 인덱스와 그에 해당하는 값을 동시에 가져올 수 있다.배열에 값 넣기plus() 를 통해 값을 쉽게 넣을 수 있다.Collection불변, 가변코틀린에서는 컬렉션을 만들 때, '불변' 인지 '가변' 인지를 설정해야한다.언어 레벨에서 개발자에게 해당 부분을 미리 신경쓰도록 한다. 🫢가변 컬렉션 (Mutablexxx) : 컬렉션에 element 를 추가, 삭제할 수 있다.불변 컬렉션 : 컬렉션에 element 를 추가, 삭제할 수 없다.
- 우리가 익숙한 이름들 (List, Set, Map 등) 이 코틀린에서는 불변 컬렉션이다.💡 Key Point
1. listOf() 는 기본적으로 불변 리스트를 만든다.
2. mutableListOf() 를 통해 가변리스트를 만들 수 있다.
3. emptyList() 를 통해 빈 리스트를 만들 수 있다. 이 또한 불변이다.List 를 이해 했다면 Set 또한 이해하기 쉽다.💡 Key Point
1. mapOf(key to value) 형식을 통해 불변 map 을 만들 수 있다.Colleciton 의 null 가능성 정리 ? 의 위치에 따라 이야기가 달라짐 
1. List<Int?>리스트에 null 이 들어갈 수 있지만, 리스트 자체는 절대 null 이 아님List<Int>?리스트에 null 이 절대 들어갈 수 없지만, 리스트 자체가 null 일 수 있다.List<Int?>?리스트에 null 이 들어갈 수도 있고, 리스트 자체가 null 일 수도 있다.ITEM 16. 다양한 함수 (확장함수, 중위함수, inline 함수)확장함수 배경 
1. kotlin 은 java 와 완벽하게 호환하는 것을 목표로 했다.🤔 : ""Java 코드 위에 자연스럽게 코틀린을 살포시 얹을 수 없을까?""""Java 코드는 그대로 두고 싶은데..""""Java 로 만들어진 라이브러리로 유지보수 하면서 동시에 확장할 때는 코틀린을 '덧붙이고' 싶어!""어떤 클래스 안에 있는 메서드 처럼 호출할 수 있지만, 함수 밖에 만들 수 있게 하려고 함.즉, 함수의 코드 자체는 클래스 밖에 있는데, '마치 클래스 안에 있는 멤버 함수 처럼' 사용하려는 것!String 클래스 안에 있는 메서드 처럼 호출 한다.하지만 실제로 String 클래스 안에는 customLastChar() 라는 함수가 없다.!! 🫢this 를 통해 '실제 클래스 안의 값에 접근` 이 가능하다 🫢 개쩐다..!""String 을 확장하는구나!!""확장 프로퍼티확장 함수의 개념은 여기서 멈추지 않았다.'확장 프로퍼티' 라는 신박한 녀석이 생겼다.이렇게 마치 프로퍼티가 클래스에 선언되어 있는 것처럼 커스텀하여 확장해서 사용이 가능하다. 🫢멤버 함수 vs 확장함수
클래스의 멤버함수와 확장함수의 시그니처가 같다면 어떻게 될까?결론 : 원조가 승리함. 즉, 멤버함수가 우선적으로 호출된다.그러므로, 확장함수를 만들었는데 다른 기능의 똑같은 시그니처의 멤버함수가 생기면 생각지 못한 오류가 생길 수 있으므로 주의!캡슐화가 깨질 염려는 없나?확장함수가 public 이고, 확장하는 클래스의 private 함수를 가져오면 캡슐화가 깨지는 거 아닌가?
->  확장함수는 클래스에 있는 private 또는 protected 멤버를 가져 올 수 없다!확장함수가 override 된다면?사용하는 측면에서, 해당 변수의 '현재 타입' 에 따라 어떤 확장 함수가 호출 될지 결정된다.💡 Key Point
1. 확장함수가 override 되는 경우 사용하는 변수의 타입에 따라 결정된다.
2. case 2 가 특이한데, Srt() 로 변수가 생성 되었으나, 선언된 타입은 부모타입인 Train 이므로, 확장함수는 Train 의 확장함수를 호출한다.중위함수""함수를 호출하는 새로운 방법!""신박하다. 개쩐다. 🫢💡 Key Point
1. 중위함수는 infix 키워드로 선언한다.
2. 변수 함수이름 arg 형태로 함수를 호출한다.inline 함수사용처
1. 함수 호출 대신, 함수를 호출한 지점에 함수 본문을 그대로 복붙 하고 싶은 경우에 사용된다.
2. 함수를 호출하는 것이 아니라, 말그대로 함수 본문 자체가 사용하는 곳에 붙여 넣게 된다.
3. 함수를 파라미터로 전달할 때의 오버헤드를 줄일 수 있다.
4. ⛔️ 주의 ! 성능 측정이 꼭 필요하고, 신중하게 사용되어야 한다.코드를 디컴파일 했을 때, 함수 본문 자체가 말 그대로 사용하는 곳에 붙여 넣게 됨. 지역함수함수 안에 함수를 넣을 수 있다!그런데 사실 잘 사용되지 않는다.이유 1. depth 가 깊어진다.이유 2. 코드가 깔끔하지 않다.이유 3. 코드의 책임이 많아진다. -> private 으로 다른 함수로 빼는 것이 좋다.🙄 딱 봐도 별로다. 따로 함수를 분리하고 싶다. ㅎ..ITEM 17. 람다(Lambda)람다 문법Java 에서의 LambdaJava 에서 함수는 '2급 시민' 이다. 😭 2급 따위..즉, Java 에서 함수는 '변수에 할당' 되거나 '파라미터로 전달 될 수 없다.'단지, 함수를 직접 넘겨주는 '것 처럼' 쓸 수 있다. Java 에서는 Lambda 가 그렇게 사용된다.Kotlin 에서의 LambdaJava 와는 근본적으로 다르다.Kotlin 에서는 함수가 '그 자체로 값' 이 될 수 있다. 즉, 변수에 할당 이 가능하다.Kotlin 에서는 함수가 파라미터로 전달 될 수 있다.💡 Key Point
1. 함수를 변수에 할당이 가능하다. 🫢
2. 방법 2 처럼 '이름 없는 함수' 즉, Lambda 를 변수에 할당 가능하다.💡 Key Point
1. 할당한 변수명에 할당된 함수의 파라미터를 넘겨주면 된다.
2. invoke 를 통해 명시적으로 함수를 호출 할 수도 있다.함수의 타입
1. Java 개발자로서는 '함수의 타입' 이라는 것이 좀 낯설다.함수의 타입 이라면 '리턴 타입'이 익숙한데, 여기서 말하는 것은 '함수 자체의 타입' 을 의미한다. isApple() 의 타입은 (Fruit) -> Boolean 이다.💡 Key Point
1. 함수의 타입은 (함수 파라미터 타입, ...) -> 함수의 반환 타입 이다.즉, isApple 함수는 Fruit 타입의 변수가 파라미터로 들어가며, Boolean 을 리턴하므로,
isApple 함수는 (Fruit) -> Boolean 타입이다.1급 시민과 2급 시민의 차이.. 🫢💡 Key Point
1. 코틀린에서는 함수가 1급 시민이므로, 파라미터로 넘길 수 있다. filter: (Fruit) -> Boolean : (Fruit) -> Boolean 타입의 함수인 filter 를 파라미터로 받는다.참고로 fruits.filter(..) 에서 호출된 filter 는 Collection 에 있는 filter 다. java 의 stream 에 있는 것과 같다고 보면 된다. 혹시가 헷갈릴까봐 ㅎㅎ 🫠💡 Key Point
1. case 1함수를 할당한 변수 isApple 을 넣어 줄 수있다.case 2filterFruits() 함수의 마지막 파라미터가 함수일 경우 중괄호를 바깥으로 빼서 넘길 수 있다.소괄호 안에 해당 함수가 들어가도 되지만, 소괄호 안에 중괄호 들어가는게 조금 어색하기 때문이다.물론, 소괄호 안에 들어가 있어도 상관없다.case 3함수를 선언한 곳에서 파라미터로 들어올 함수의 파라미터 타입이 무엇인지 알기 때문에 : Fruit 를 생략할 수 있다.case 4 it 으로 대체될 수 있다. 클로저 Java 에서는 문제가 있다람다 로직 내부에서 예외가 난다.Java 에서는 람다를 쓸 때 사용할 수 있는 '변수'에 제약이 있다.
- final 인 변수 혹은 실질적으로 final 인 변수만 사용할 수 있다.
즉, targetFruitName 의 값이 변경되었으므로 람다에서 사용이 불가능해 진 것이다.
Variable used in lambda expression should be final or effectively final
즉, targetFruitName 의 값이 변경되었으므로 람다에서 사용이 불가능해 진 것이다.Variable used in lambda expression should be final or effectively final Kotlin 에서는 아무 문제 없다. 아무 문제 없이 사용이 가능하다!코틀린은 '람다가 시작하는 지점 (즉, it.name == targetFruitName 이 실행되는 시점) 에 참조하고 있는 변수들을 모두 '포획'한다.그래서 포획된 모든 변수들의 정보를 가지고 있다.이렇게 해야만 람다를 진정한 '일급 시민' 으로 간주 할 수 있다.이러한 데이터 구조를 '클로저 (Closure)' 라고 한다.
- 람다가 실행되고 있는 시점에 쓰고 있는 모든 변수들을 포획한 데이터 구조ITEM 18. 컬렉션을 함수형으로 다루기Filter 와 Map💡 Key Point
1. filter 에 조건을 함수로 넘겨준다.
2. it 을 사용할 수도 있다.💡 Key Point
1. 필터에 인덱스가 필요하다면 filterIndexed 를 사용할 수 있다.💡 Key Point
1. 매핑을 하고 싶다면 map 을 사용할 수 있다.
2. currentPrice 정보들로 리스트가 매핑된다.💡 Key Point
1. 매핑과 동시에 인덱스를 가지고 오고 싶다면 mapIndexed 를 사용할 수 있다.
2. 리스트가 매핑되는 값은 가장 아래의 fruit.currentPrice 로 매핑이 된다.💡 Key Point
1. 매핑의 결과가 null 이 아닌 것만 가지고 오고 싶을 때 mapNotNull 을 사용한다.
2. 여기서 매핑의 결과가 null 이라는 의미는, 매핑된 결과 즉, 객체의 currentPrice 가 null 인 경우를 의미한다.다양한 컬렉션 기능 (all, none, any, count, sorted, distinctBy, first, last)💡 Key Point
1. all : '모든 조건을 만족'하면 true, 하나라도 아니면 false
2. none : all 과 반대. 조건을 '모두 만족하지 않으면' true, 하나라도 만족하면 false
3. any : 조건을 '하나라도 만족하면' true, 모두 만족하지 않으면 false💡 Key Point
1. count : 컬렉션의 개수를 리턴한다.
2. sortedBy : 함수에 들어온 값을 기준으로 정렬한다. 기본은 오름차순 (asc) 이다.
3. sortedByDescending : 내림차순으로 정렬한다. (desc)
4. distinctBy : 함수에 들어온 값을 기준으로 중복을 제거한다. 💡 Key Point
1. first : 첫번째 값을 가져온다. (null 이 아니어야 한다.)
2. firstOrNull : 첫번째 값 또는 null 을 가져온다.
3. last : 마지막 값을 가져온다. (null 이 아니어야 한다.)
4. lastOrNull: 마지막 값 또는 null 을 가져온다.List 를 Map 으로 변환💡 Key Point
1. groupBylist (fruits) 를 groupBy 에 명시한 것 기준으로 묶어서 Map 컬렉션이 된다.value 값도 함께 기준을 정하고 싶다면 groupBy 에 순차적으로 key, value 순으로 정해주면 된다.associatedByvalue 가 list 가 아닌 경우에는 associatedBy 를 사용한다. associatedBy 는 말 그대로, 함수에 값들을 '모아주는' 기준점을 제시하는 것.println(mapAssociatedBy) 출력값 :
- {사과=Fruit(id=4, name=사과, factoryPrice=1500, currentPrice=5000), 바나나=Fruit(id=7, name=바나나, factoryPrice=2500, currentPrice=7090), 수박=Fruit(id=8, name=수박, factoryPrice=10000, currentPrice=12800)}중첩된 컬렉션 처리💡 Key Point
1. flatMapflatMap 을 사용하면 list<list<Fruit>> 가 list<Fruit> 가 된다.위 예제는, 중첩 리스트를 한번 flat 하게 핀 후에, filter 를 통해 factoryPrice 와 currentPrice 가 같은 경우를 뽑아내는 것.확장함수를 이용하면 더 깔끔하고 가독성 있게 만들 수 있다.List<Fruit> 라는 타입에다가 samePricefilter 라는 확장함수를 추가한다. 해당 확장함수는 Fruit 클래스에 선언되어있는 isSamePrice 를 filter 로 거른 List<Fruit> 를 리턴한다.flatten그냥 어떠한 조건 없이 중첩 리스트를 피는 것!list<list<Fruit>> 가 list<Fruit> 로 순수하게 변환!ITEM 19. 코틀린의 이모저모Type Alias 와 as import💡 Key Point
1. 긴 이름의 클래스 혹은 함수 타입이 있을 때, 축약하거나 더 좋은 이름을 사용하고 싶을 때 유용하다.(Fruit) -> Boolean 타입의 함수타입을 FruitFilter 로 이름을 주고 사용💡 Key Point
1. 위와같이 이름이 긴 클래스를 컬렉션에 담아서 사용할 때도 유용하게 사용이 가능하다.💡 Key Point
1. 다른 패키지의 같은 이름인 함수를 동시에 가지고 오고 싶을 때 사용한다.구조분해와 componentN 함수 구조분해 
1. 의미복합적인 값을 분해하여 여러 변수를 한 번에 초기화 하는 것을 의미함.흠.. 🤔 뜻이 이해하기 상당히 어렵다.
아래의 예제를 보자!💡 Key Point
1. 예제를 통해 보면 별거 없다.변수를 초기화 할 때, 복합적인 값 (여기서는 person 객체) 을 분해해서 한번에 초기화 하는 것!이 예제를 보고 위의 구조분해의 의미를 다시 보면 이해된다. 별거없다. ⛔️주의구조분해는 data class 에서만 가능하다.그 이유는 componentN 함수라는 비밀에 있다. componentN 함수 
1. data class 는 componentN 이라는 함수를 자동으로 만들어준다.
2. componentN 함수란?data class 는 선언된 필드의 순서대로 component 함수를 만들어준다.N 의 의미는 선언된 프로퍼티의 순서를 의미한다.위의 Person 클래스의 name 은 1번, age 는 2번 .. 이런 식이다. name 이나 age 라는 이름으로 인식하지 않고 프로퍼티 순서로 값을 가져온다.일반 클래스에서 구조분해 할당을 하고 싶다면 componentN 함수를 만들어주면 된다.💡 Key Point
1. 일반 클래스에서 componentN 함수를 구현 했다.
그리고 나서 구조분해 할당이 가능해졌다.
2. 여기서 주의해야 할 점은 componentN 함수를 구현할 때, operator 연산자를 붙여야 한다는 것이다.
즉, 코틀린은 componentN 함수를 연산자로 인식한다는 것이다.takeIf 와 takeUnless💡 Key Point
1. 주어진 조건을 만족하면 그 값이 반환되며, 그렇지 않으면 null 이 반환된다.
2. takeIf 를 사용한 값을 return 하게 되면, return 타입은 nullable 한 곳에 사용되어야 한다.
3. takeUnlesstakeIf 와 반대주어진 조건을 만족하지 않으면 그 값이 반환되고, 만족한다면 null 이 반환된다.ITEM 20. Scope FunctionScope Function 이란 개념을 잡자 의미 : '일시적인 영역' 을 형성하는 '함수'람다를 사용해서 일시적인 영역을 만들고 코드를 더 간결하게 만든다.메서드 체이닝을 활용하여 코드를 보다 간결하게 만든다.💡 Key Point
1. let 을 통해 '일시적인 영역' 이 생겼다. 이 영역은 람다가 된다.람다 안에서 it 을 통해 person 에 접근한다.let 은 람다를 받고, 그 람다의 결과를 반환 한다. (밑에 더 자세하게 서술한다.)Scope Function 의 종류💡 Key Point
1. Scope Function 은 총 5가지let, run, also, apply, withwith 를 제외한 4가지는 모두 '확장함수'로 사용한다.Scope Function 은 모두 람다 형식으로 사용된다.let, run : 람다의 결과를 반환한다.also, apply : 람다 내에서 뭔가를 해도 객체 자체를 반환한다.let, also : 람다 내에서 it 을 사용한다.run, apply : 람다 안에서 this 를 사용한다. 💡 Key Point
1. 람다에서는 가장 마지막 줄이 return 된다.
2. let, run 은 람다의 결과가 반환된다.
3. 즉, person 의 age 가 반환된다.💡 Key Point
1. also, apply 에서 반환되는 람다는 객체 그 자체가 반환된다.
2. 그러므로 println 을 통해 콘솔에 찍히는 값은 객체의 주소값이다.
람다의 결과는 해당 scope function 의 return 값과는 무관하다.
확장함수로 사용된 객체의 클래스 자체가 반환된다.💡 Key Point
1. with 는 확장함수로 사용되지 않으므로 사용법이 조금 다르다.
2. 객체를 with 의 파라미터로 받아서 사용한다.
3. this 를 통해 객체에 접근이 가능하다.let 의 사용하나 이상의 함수를 call chain 의 결과로 호출할 때 사용.non-null 값에 대해서만 코드블럭을 실행시키고 싶을 때 사용.?. 을 통해 non-null 인 경우에 let 을 사용한 함수가 실행 된다.이 경우를 가장 많이 사용한다.일회성으로 제한된 영역에 지역변수를 만들 때 사용.firstNumber 라는 지역변수를 let 을 통한 람다의 영역에 만들고, 이 변수를 통해 편하게 return 값을 요리한다.run 의 사용'객체 초기화' 와 반환 값의 계산을 동시에 해야 할 때 사용.위의 예제는 person 객체를 초기화 함과 동시에 '객체를 만들어서 DB 에 저장' 한다.하지만 이런 방법은 잘 사용되지 않는다.apply 의 사용apply 는 실행된 람다에서 객체 그 자체가 반환된다.객체를 설정할 때, 객체를 '수정' (즉, apply - 적용) 하는 로직이 메서드 call chain 의 중간에 필요할 때 사용.also 의 사용also 는 apply 와 마찬 가지로, 실행된 람다에서 객체 그 자체가 반환된다.객체를 수정하는 로직이 call chain 의 중간에 필요할 때 사용된다. with 의 사용💡 Key Point
1. 특정 객체를 다른 객체로 변환해야 하는데, 모듈 간의 의존성에 의해 정적 팩토리 메서드 혹은 toClass 함수를 만들기 어려울 때 사용.
2. 객체 컨버팅할 때 많이 사용된다.
3. 위의 예시에서는 this 를 사용했으나, 생략할수 있다.
this 를 생략할 수 있기에 필드가 많아도 코드가 간결해진다.Scope Function 을 활용한 함수형 프로그래밍
과한 Scope Function 은 숙련된 코틀린 개발자가 아닌 경우 보기 힘들다.🫠
과한 Scope Function 은 숙련된 코틀린 개발자가 아닌 경우 보기 힘들다.🫠
디버깅이 힘들다.
디버깅이 힘들다.
그로 인한 수정이 힘들 수 있다.
그로 인한 수정이 힘들 수 있다.
하지만, 적절하게 사용하면 아주 유용하게 활용이 가능하다.
하지만, 적절하게 사용하면 아주 유용하게 활용이 가능하다.
💡 팀의 코틀린 숙련도와 선호도에 따른 컨벤션을 정하는 것이 중요하다.
💡 팀의 코틀린 숙련도와 선호도에 따른 컨벤션을 정하는 것이 중요하다.🎉 결론이제, 코틀린의 기초를 끝냈다. 만세!!다시 공부하면서 글을 정리하니까 생각보다 시간이 꽤 걸렸다.Java 에 익숙한 개발자들이 이 글을 통해 Kotlin 기초 문법을 학습하는데 도움이 되면 좋겠다.그리고 위의 서론에서 이야기했지만, 최태현님 코틀린 강의를 듣고 이 글을 보면 좋겠다.강의를 통해 공부하고 이 글은 복습과 까먹었을 때 다시 상기시키는 사전 처럼 사용되면 좋겠다.그럼, 이제 다음 강의 부수러 가보잣! 🍰수강하면서 자세히 정리한 게 인상적입니다. 언제나 개발을 대하는 자세를 배웁니다! 좋은 포스팅 잘 봤어요광기가 느껴집니다...자바 개발자로 일하면서 다음 스터디를 코틀린 생각중인데 잘 정리해주신 글 덕분에 코틀린 맛보기 해봤습니다! 코틀린 재밌어 보이네요!😁",https://velog.io/@joshuara7235/Java-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-Kotlin-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0-%EA%B8%B0%EB%B3%B8%EA%B8%B0
너와의 추억을 우주의 별로 띄울게,도라에몽의 코드빵 🍞,https://velog.velcdn.com/images/greencloud/post/fe07146d-81db-4b2f-a2ba-119d1ad8b6f9/image.JPG,"너와의 추억을 우주의 별로 띄울게Three.js와 친해져보자!부스트캠프 웹모바일 8기 Web16팀. 우리 프로젝트의 내용이다.'내 삶의 반짝이는 기억들을 은하로 만들 수 있다면 어떨까' 라는 생각에서 나온 주제로,
자신만의 우주에 기억을 담은 별을 띄울 수 있는 서비스이다.우리가 프로젝트를 구현해나가는 과정을 블로그로 작성해보려 한다.
그 중 <너와의 추억을 우주의 별로 띄울게> 시리즈는 3D로 우주를 구현하는 것에 초점을 맞춰 글을 작성한다.프로젝트를 구경하고 싶으면 아래의 깃헙으로.. 🚀
https://github.com/boostcampwm2023/web16-B1G1프로젝트 진행과정은 wiki에 기록하고 있다.
https://github.com/boostcampwm2023/web16-B1G1/wiki글을 작성하고 있는 오늘을 기준으로 프로젝트 극 초반이기 때문에 아직 코드가 많이 작성되어 있지 않다.
앞으로의 진행과정이 궁금하다면 가끔 와서 구경해주시길.. 🙏🏻피드백과 지적은 언제나 환영합니다.
PR에 냅다 리뷰 다셔도 좋습니다.++ 아래 내용들은 프론트엔드 팀원분들과 페어프로그래밍한 결과물임을 밝힌다.
팀원들의 블로그 링크 투척하고 간다
https://velog.io/@minboykim
https://velog.io/@200tiger아무튼 이제 본격적으로 코드를 작성해보자.
우리 프로젝트에서는 Three.js + React-Three-Fiber를 사용하여 3D 요소들을 구현한다.
Three.js에 대한 기본적인 지식을 공부하고 싶다면 아래 글을 읽어보고 오는 것을 추천한다.Three.js와의 설레는 첫만남 😳
JS로 자전과 공전을 구현할 수 있다고?오늘은 배경이 될 우주를 만들어보겠다.
까만 배경에 작은 별들을 렌더링하는 과정이다.🍞 Screen 컴포넌트 생성우리는 Canvas를 통해 Scene을 구성할 수 있다.
Scene은 도화지같은 역할이다.
Scene이라는 도화지가 있어야 그 위에 다른 요소들을 그려낼 수 있다.Screen이라는 컴포넌트 내에 Canvas를 생성해보자.먼저 Canvas에 style을 주어 전체 화면을 차지하도록 하자.다음으로 camera 속성을 추가한다.
이 속성을 통해 우리가 3D 화면을 어디서 어떻게 바라볼지 설정할 수 있다.position 속성은 카메라의 위치를 의미한다.
[0, 2000, 2000]은 각각 x, y, z축에 대한 위치를 의미한다.
즉 카메라를 y축과 z축 방향으로 2000만큼 떨어진 위치에 놓은 것이다.rotation은 카메라의 회전을 설정한다.
[-0.5, 0, 0]은 각각 x, y, z축에 대한 회전 각도를 의미한다.
여기서 회전 각도는 라디안 단위로 표현된다.
문과생인 나는 여기서부터 살짝 당황했다.
하지만 여기까지는 아직 쉽다.
라디안은 각도 측정 단위중 하나이다.
원주율 π 라디안이 180도에 해당한다.
즉 -0.5 라디안은 약 -28.65도 정도이다.
카메라의 회전을 [-0.5, 0, 0]으로 설정했다는 것은 카메라의 시점이 y축의 음의 방향으로 28.65도정도 기울어져있다는 뜻이다. far은 카메라가 보여줄 수 있는 최대 거리를 설정한다.
far을 100000을 설정했다는 것은, 요소와 카메라 간 거리가 100000보다 멀어지면 요소가 보이지 않는다는 뜻이다.사실 현재 카메라 설정값들은 다 임시로 한 것이라, 값에는 큰 의미를 두지 않아도 된다.
모두 개발을 진행함에 따라 변경될 예정이다.
각각의 속성이 어떤 것을 뜻하는지만 이해하면 될 것 같다.color에서는 background 속성의 색상을 #000으로 설정했다.
이렇게 하면 화면 전체가 까맣게 보인다.
attach에는 background 말고도 Scene 객체가 가진 속성 중 color 값을 가질 수 있는 속성들을 넣을 수 있다.ambientLight는 주변 광원을 설정한다.
이 광원은 방향이 없으며 Scene에 있는 모든 요소를 균일하게 비춘다.
여기서는 색상을 흰색으로, 강도를 5로 설정했다.
광원이 있어야 보이는 material이 있고, 없어도 보이는 material이 있다.
우리는 이후 광원이 있어야 보이는 material도 사용할 예정이라 	ambientLight를 설정해주었다. 마지막으로 OrbitControls를 추가했다.
이것을 추가함으로써 우리는 이제 3D 화면을 탐색할 수 있다.
이것이 없을 땐 우린 그저 화면을 바라보기만 할 수 있다.
우리가 OrbitControls를 추가함으로써 마우스나 터치 이벤트를 통해 카메라의 줌, 회전 등이 가능해졌다.이제 Canvas 설정은 끝났다.
본격적으로 배경 별들을 만들어보자.🍞 BackgroundStars 컴포넌트 생성1. Geometry, Material 생성우리는 pointsMaterial을 사용하여 배경 별을 만들 것이다.
잠시 다시 짚고 넘어가자면 하나의 덩어리, 즉 Mesh를 만들기 위해서는 Geometry와 Material이 필요하다.
먼저 이것들을 만들어보자.points는 Points 객체를 생성하는데, 이 객체는 각각의 점들로 구성되었다.
여기서 각 점이 별 하나를 나타낼 것이다.bufferGeometry는 점들의 위치를 정의하는 BufferGeometry 객체를 생성한다.
우리는 attach=""geometry""를 통해 이를 Points 객체의 geometry 속성으로 설정한다.pointsMaterial은 점들의 물리적 특성을 정의하는 PointsMaterial 객체를 생성한다.
마찬가지로 attach=""material""을 통해 Points 객체의 material 속성으로 설정한다.다음으로는 pointsMaterial 속성을 채워보자.먼저 size 속성으로 각 별의 크기를 1.5로 설정했다.다음으로 vertexColors를 true로 설정하면, 각 점의 색상이 해당 점의 vertex color에 의해 결정된다.
vertex color는 BufferGeometry의 color 속성을 통해 설정할 것이다. sizeAttenuation 속성으로는 별들이 카메라와의 거리에 따라 어떻게 보일지 결정할 수 있다.
이 속성을 false로 설정하면 점들의 크기가 카메라와의 거리에 관계없이 일정하게 보인다.
즉 원근법을 무시하게 된다.
별들이 멀든 가깝든 항상 조그맣게 보이게 설정하여, 말 그대로 '뒷 배경의 별'처럼 보이게 했다.잠깐 최종 완성화면을 보자.
sizeAttenuation이 true일 때는 첫 번째 사진과 같고, false일 때는 아래 사진과 같다.이제 별들의 위치와 색상을 설정할 때 쓰일 함수를 만들어보자.getRandomInt는 인수로 min과 max를 받아, min 이상 max 미만의 Integer 형식 수를 리턴한다.
getRandomFloat는 인수로 min과 max를 받아, min 이상 max 미만의 Float 형식 수를 리턴한다.여기서 getRandomInt는 별의 색상을 결정할 때 쓰고, getRandomFloat는 별의 위치를 결정할 때 쓸 것이다.2. 색상과 위치 결정그다음은 별들의 색상과 위치를 결정하는 함수를 만들 것이다.
여기서부터 좀 길어질 수 있으니 해당 함수 부분만 따로 떼서 보자.먼저 별들의 x, y, z 좌표를 담은 positions 배열을 만든다.
한 별 당 x, y, z 세 개의 좌표가 들어가므로 배열의 길이는 ( 배경 별 수 * 3 ) 가 된다.
그리고 우주의 범위 내에서 랜덤으로 좌표를 생성해 배열에 담는다.SPACE_MIN_SIZE가 -50000, SPACE_MAX_SIZE가 50000으로 되어있는데,
이는 원점 (0, 0, 0)을 기준으로 x, y, z좌표에서 각각 양옆으로 50000씩 뻗어나간 곳까지 우주가 존재할 것이라는 뜻이다.
예를 들어 SPACE_MIN_SIZE가 -5, SPACE_MAX_SIZE가 5일 경우 우주는 아래와 같은 영역까지 존재하게 된다.그러므로 x, y, z 좌표 모두 SPACE_MIN_SIZE 이상 SPACE_MAX_SIZE 미만의 범위에서 float 형식으로 랜덤 추출했다.다음으로 색상을 보자.
별들의 색상 r, g, b값을 담은 colors 배열을 만들었다.여기서는 배열의 길이를 배경 별 수로 하되, 하나의 요소가 [color.r, color.g, color.b] 형식이 되도록 했다.
그리고 flat()으로 배열을 평탄화했다.
BACKGROUND_STAR_COLORS의 인덱스 값으로는 0부터 3까지의 정수만 되므로 getRandomFloat가 아닌 getRandomInt를 사용했다.
4개 색상 중 랜덤으로 각 별의 색상이 결정될 것이다. 이제 positions와 colors가 완성되었다.
Three.js에서는 Float32Array를 사용하여 버퍼 데이터를 저장한다. 
배열을 해당 형식으로 변경하자.참고로 Float64Array를 사용하면 Unsupported buffer data format 에러가 발생한다.
WebGL에서 기본적으로 Float32Array를 지원하기 때문이라고 한다.여기까지 적용한 전체 코드는 위와 같다.
getBackgroundStarsInfo 함수의 결과값을 BackgroundStars 내에서 각각 positions, colors에 할당해주자.
여기서 getBackgroundStarsInfo 함수는 계산량이 많으므로 성능 개선을 위해 useMemo를 사용했다. 첫 번째 bufferAttribute에는 attach=""attributes-position""속성을 주어 위치 관련 속성들을 지정해주었다.
itemSize는 각 항목이 차지하는 크기를 나타낸다.
우리는 3차원 좌표를 사용하므로, 한 항목이 (x, y, z)로 구성되어 3만큼 차지한다.두 번째 bufferAttribute에는 attach=""attributes-color""속성을 주어 색상 관련 속성들을 지정해주었다.여기까지 하면 이렇게 예쁜 우주 배경이 보이게 된다.아래는 동작 화면이다.
gif 형식으로 바꿨더니 좀 느려져서 렉이 걸리는 것처럼 보이는데..
실제로는 전혀 렉이 걸리지 않고 잘 움직인다.하지만 이게 끝이 아니다.
별들이 회전하도록 만들어볼 것이다.
조금만..힘내보자3. 회전시키기회전 부분 코드에 집중하기 위해 잠시 BackgroundStars 내부의 코드만 살펴보자.주석 달린 부분 코드가 추가되었고, points에 ref 속성이 추가되었다.먼저 useFrame에 대해 간략히 알아보자.
useFrame의 콜백함수는 매 프레임이 렌더링되기 직전마다 실행된다.
프레임은 화면이 한 번 갱신되는데 필요한 시간 간격이다.
화면은 초당 특정 횟수로 갱신되며 이를 주로 FPS (Frame per Second)라고 한다.
기본적으로는 60FPS로 작동하는데, 초당 60번 화면이 갱신된다는 뜻이다.그리고 첫 번째 인수는 현재 렌더러 상태, 두 번째 인수는 이전 프레임과의 시간 간격을 나타내는 delta 값이다.즉 여기서는 매 프레임이 렌더링 될 때마다 pointsRef.current.rotation.y 값을 업데이트하고 있다.
pointsRef의 y축 회전 값을 바꾸는 것이다.
( 이전 프레임과 현재 프레임 간 시간 차이 ) / 150 만큼을 계속해서 회전 값에 더해주어 points를 회전시킨다.
150보다 값이 커지면 회전이 느려지고, 값이 작아지면 회전이 빨라진다.
우리는 사용자의 눈이 피로하지 않도록 굉장히 느리게 회전하게 설정했다.이제 모든 코드가 완성되었다.
동작 화면을 보자.gif 변환하면서 영상이 느려지니 delta / 15로 설정하고 녹화했는데 실제로는 이것보다 더 느리게 회전한다.이제 최종 코드를 보자.실제 프로젝트에서는는 함수나 상수를 다른 곳에서 정의하고 import 해오는 식으로 했는데, 블로그 작성을 위해 한 파일에 모두 옮겼더니 코드가 좀 길어보인다. 😅아무튼 이렇게 우주의 배경 별 만들기가 끝났다.
다음 글은 은하 만들기가 될 것 같다.
살짝 스포를 해보면... 이런 느낌이 되겠다.아직 미완이라 확정은 아니지만 대충 저런 느낌으로 될 것 같다.
다음 글은 훨씬 어려운 내용이 되겠지만 다들 기다려줘....참고 자료CanvasAmbientLightPointsR3F hooksJS로 자전과 공전을 구현할 수 있다고? 썸네일 보고 들어왔는데 재밌는 내용이네요 잘봤습니다!",https://velog.io/@greencloud/%EB%84%88%EC%99%80%EC%9D%98-%EC%B6%94%EC%96%B5%EC%9D%84-%EC%9A%B0%EC%A3%BC%EC%9D%98-%EB%B3%84%EB%A1%9C-%EB%9D%84%EC%9A%B8%EA%B2%8C
어쩌다 토스페이먼츠 개발자가 되었을까? 고등학생들이 물었습니다,tosspayments.log,https://velog.velcdn.com/images/tosspayments/post/2aa566c9-4a1c-4636-8ac9-2a87fe4291f2/image.png,"어쩌다 토스페이먼츠 개발자가 되었을까? 고등학생들이 물었습니다지난 2일, 토스페이먼츠 개발자들과 대덕소프트웨어마이스터고등학교 1학년 학생 63명이 만나 이야기 나누는 자리를 가졌어요. 취업을 목표로 하는 소프트웨어 개발자로서 기업 탐방을 오신 건데요. 토스페이먼츠 라운지에서 소프트웨어 개발자가 가져야 할 기본 역량과 학습 방향 등을 함께 나누었답니다.
문제 해결 역량을 쌓으려면세 분이 공통적으로 강조하신 이야기가 있었는데요. 좋은 엔지니어가 되려면 문제 해결 역량을 쌓아야 한다는 이야기였어요. 재엽님은 한 가지 분야를 파고들기 전에 프로그래밍에 대한 전반적인 이해를 먼저 쌓는 것을 추천해주셨어요. 전반적으로 이해를 해야 복잡한 문제를 정의하고 해결할 수 있기 때문이죠. 요즘 프론트엔드 개발 생태계는 문제도, 문제를 해결하는 도구의 난이도도 굉장히 복잡해지고 있기 때문에 직접 문제를 정의하고 해결하려면 더 넓은 시야에서 생각할 수 있어야 해요.규주님은 실제 운영 경험의 중요성에 관해 이야기 해주셨어요. 운영 없는 개발은 아이디어 사고 실험일 뿐, 직접 운영하면서 겪은 문제들을 해결하면서 많이 성장 하셨다고 해요. 특히 이커머스 서비스를 만들어 보는 것을 추천하셨는데요. 이커머스 서비스를 다루면 상품 관리를 위한 자료구조와 이미지 등의 정적 리소스 관리, 상품 검색을 위한 성능 개선과 캐시 처리, 찜하기 기능으로 동시성과 멱등성을 경험해 볼 수 있어요. 마지막으로 가장 중요한 결제 연동까지! 전방위적으로 개발을 통한 문제 해결을 경험해 볼 수 있어요.재은님은 문제 해결 역량을 잘 쌓으려면 자신이 좋아하는 분야를 잘 탐색해 봐야 한다는 점을 짚어주셨어요. 단순히 취업해야 한다는 생각보다는 내가 어떤 일을 할 때 즐거운지 깊이 고민해 봐야 문제 해결도 더 잘할 수 있기 때문이에요.Q&A 세션세션 후 Frontend, DevOps, Server 세 그룹으로 나뉘어서 Q&A 세션을 했어요. 몇 가지 내용을 함께 공유해 볼게요.FrontendQ. AI가 어디까지 개발할 수 있을까요? 그리고 어떤 준비를 해야 AI가 대체할 수 없는 인재가 될 수 있을까요?A. 저도 알고 싶네요. 다만 아직은 개발자에게 도움을 주는 정도의 도구라고 생각하고 있긴 해요. AI가 개발자를 대체하는 영역들은 개발자가 귀찮아하는 영역들, 즉 일부라고 보고 있어요. 제품을 만들고, 문제를 해결하는 능력은 개발자가 반드시 가져야 하는 역량이고 AI가 바로 대체하기 어려울 것으로 보여요.Q. 개발하다가 생각이 안 나거나 막히는 부분이 있을 때 본인만의 해결 방법이 있으신가요?A. 옆에 있는 동료한테 물어봐요. 그게 제일 빨라요. 다만 저는 그 전에 15분 정도 혼자 고민하는 시간을 가져요. 개발에서 절대 해결 못 하는 건 없다고 생각해요. 로그에 전부 기록이 남고, 그 기록을 잘 분석하면 해결 방법이 나오니까요. 근데 그게 가장 어렵거든요. 혼자서만 문제를 해결하려고 하면 문제가 안 보여요. 다른 사람을 불러서 문제를 설명하다 보면 별거 아닌 이유를 발견해서 해결할 때도 있고, 심지어 설명하다가 해결되는 경우도 꽤 많은 것 같아요.Q. Frontend를 1년 정도 공부한 뒤에 어느 정도 역량이 되어야 하나요?A. 한 분야로 너무 파고들기 전에 웹을 다 경험해 보셨으면 좋겠어요. 웹 자체를 충분히 경험해 보고 나서 Frontend에 집중해도 괜찮아요. 그래야 나중에 협업하거나 문제가 발생했을 때 어디를 봐야 할지 알 수 있거든요. 요즘은 Vercel 같은 제품이 너무 잘 되어 있어서 정말 쉽게 배포할 수 있게 됐죠. 그런데 막상 그 안에서 무슨 일이 일어나는지는 알기 어려워요. 저는 그 알기 어려운 부분을 파봐야 한다고 생각해요.또, 특정 분야와 상관없이 중요한 지식들이 있거든요. 추상화나 객체 지향, 좋은 코드는 몇 개월 공부한다고 알 수 있는 건 아니에요. 오랫동안 고민하고 이해해 보는 시간을 가져보세요. 예를 들면 컴포넌트 하나를 만들 때도 왜 이 코드가 여기 있어야 하는지 깊이 생각해 보세요. 그러려면 테스트 코드를 잘 짜야 해요. 그래서 Frontend 개발자가 되기 위해 React를 공부한다면 React로 만들어진 컴포넌트를 어떻게 테스트할 것인지 동시에 공부해야 합니다.DevOpsQ. 토스페이먼츠의 배포 파이프라인은 어떤 구조로 되어있고 어떻게 운영하고 있나요?A. DevOps 팀은 최대한 효율적으로 일하는 것을 추구하고 있어요. 그래서 많은 것들을 자동화하려 노력합니다. 저희는 쿠버네티스를 주로 사용하는데요. 최근에는 쿠버네티스에 익숙하지 않은 개발자도 바로 배포 파이프라인을 사용할 수 있는 UI를 실험하고 있어요.Q. 토스페이먼츠 서버들은 마이크로 서비스 아키텍처로 되어있나요? 각 서비스간에 트랜잭션은 어떻게 공유하나요? 분산 트랜잭션 같은 기법도 사용하나요? A. 마이크로 서비스 아키텍처를 추구해요. 대신 하나의 요청이 어떤 서비스를 거쳐 갔는지 쉽게 알 수 있도록 분산 추적 체계가 구축되어 있어요. 다만 이런 기술 자체보다는 제품 개발의 속도를 받아주면서도 속도, 장애 모니터링 등을 원활히 하기 위한 팀 간 커뮤니케이션이 가장 중요하다고 생각해요.Q. 서비스가 여러 개인데 앞 단에서 인증을 붙여 운영할 땐 어떻게 해야 되나요?Spring Cloud Gateway와 AWS Lambda Edge 등을 사용해서 공통 인증 로직을 개발하고 운영하고 있어요. 개발자가 ‘인프라가 투명하다’고 느끼도록 노력해야 DevOps의 운영 난이도가 오히려 내려가요. 그래서 Istio, AWS ELB 등을 통해서 투명한 인프라를 구성하기 위해 노력하고 있어요. 개발자분들도 DevOps 엔지니어나 Infra 엔지니어 개입 없이도 편하게 운영하실 수 있도록 Spring Cloud Gateway를 사용하고 있어요.ServerQ. 사용할 프레임워크나 기술 스택, 아키텍처 등을 결정할 때 기준이 있나요?A. 내가 만드는 것을 언젠가 다른 사람이 맡게 될 확률이 높기 때문에 서버 챕터 전체적으로 맞춰서 정하긴 해요. 물론 제품 특성에 따라 전혀 다른 스택을 선택할 수도 있는데요. 제품이나 회사에서 다루는 도메인에 따라 다른 건 어디나 비슷할 것 같아요. 예를 들어 데이터를 다루는 회사라면 Python을 쓰겠죠. 다만 토스페이먼츠 팀의 판단 기준은 내가 제품을 만드는 데 있어서 가장 좋은 도구를 선택하는 거라고 할 수 있어요.Q. 개발 역량 외에 개발자가 갖춰야 할 중요한 역량은 또 어떤 게 있나요?A. 하나만 꼽기 어렵네요. 그래도 꼽아보자면 ‘주도성’이라는 생각이 들어요. 주도성은 개발자가 아닌 어떤 직군이라도 중요한 역량이고요. 다음은 당연히 ‘커뮤니케이션 능력’이에요. 아무리 개발 역량이 뛰어나더라도 자기 혼자 나아가 버리는 게 아니라, 진행되고 있는 일을 투명하게 공유하는 게 중요해요.Q. 창업 경험 중 토스에 합류하는 데 도움이 된 것은 어떤 건가요?A. 저는 ‘토스 Next 개발자’라는 신입 채용 전형을 통해 들어왔어요. Next 채용은 경력이 얼마나 긴지가 아니라 잠재력을 보는 편이에요. 그럼에도 창업 경험이 큰 도움이 됐다고 생각하는데요. 일단 혼자 이커머스 서버 개발을 전부 맡아 했어요. 서비스를 밑바닥부터 만들었고 앞서 말씀드렸던 것처럼 이커머스의 다양한 기능들을 10개월에서 1년 정도 다뤄봤어요. 유저 관리, 상품 관리, 가맹점 관리, 결제와 정산, 발주와 환불 등 수많은 기능을 만들고 운영해 본 경험이 큰 도움이 되었어요.토스페이먼츠는 잠재력이 많은 미래 개발자와 같이 일하기를 기다리고 있어요. 토스페이먼츠 개발팀에 합류해서 함께 문제를 해결해 나가요!Edit 한주연, 박수연 Photo 김예솔, 홍가영 Graphic 이은호, 함경주토스페이먼츠 Twitter를 팔로우하시면 더욱 빠르게 블로그 업데이트 소식을 만나보실 수 있어요.토스페이먼츠 홈페이지토스페이먼츠 개발자센터토스페이먼츠 GitHubnull 리턴은 왜 나쁠까?Feign 코드 분석과 서버 성능 개선개발하다가 막힐 때 혼자 고민한 뒤에 옆에 개발자 동료분에게 여쭤보는게 가장 빠르다는 말이 너무 공감되네요 ㅎㅎ 저도 실제로 저 혼자 문제를 붙잡고 있을 때는 해결책이 안보이다가, 옆자리 동료분께 여쭤보고 금방 해결했던 적이 많았거든요 ㅎㅎ 알고보니 정말 별거 아닌 것이었는데, 그게 내 눈에는 안보일 때가 종종 있어서 그럴 땐 다른 사람의 힘을 잠시 빌려보는 것도 방법이지요 😊",https://velog.io/@tosspayments/%EC%96%B4%EC%A9%8C%EB%8B%A4-%ED%86%A0%EC%8A%A4%ED%8E%98%EC%9D%B4%EB%A8%BC%EC%B8%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C-%EA%B3%A0%EB%93%B1%ED%95%99%EC%83%9D%EB%93%A4%EC%9D%B4-%EB%AC%BC%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4
[Java] IntelliJ에서 Java 테스트 커버리지 확인하기 (feat. 우테코),pgmjun.log,https://velog.velcdn.com/images/pgmjun/post/5302cf53-17c0-456c-a566-a719eb2d20d3/image.png,"[Java] IntelliJ에서 Java 테스트 커버리지 확인하기 (feat. 우테코)java내 테스트 코드는 제대로 작성되었을까? 🤔우테코 프리코스를 진행하면서 요구사항에 의해 테스트 코드를 작성하였다.
실수를 방지하기 위해 정말 꼼꼼하게 테스트 코드를 작성하며, 엣지 케이스를 찾기 위해 열심히 노력하였다.하지만 미션 코드가 길어지다보니 ""모든 로직에 대한 테스트가 되어있는가?""라는 스스로에 대한 의구심이 들기 시작했다.때문에 이 의구심을 해결하기 위한 방법을 찾아보았고, 인텔리제이에서 플러그인 설치없이 코드 커버리지를 측정을 할 수 있다는 것을 알 수 있었다.나는 이를 활용해 최대한 모든 로직을 테스트 할 수 있었고, 몇 번의 클릭만으로 많은 장점을 얻을 수 있다고 생각했기 때문에 이를 공유하고자 간단히나마 글을 작성해보고자 한다.💭 코드 커버리지란?코드 커버리지는 내 프로젝트의 코드들의 테스트 코드에서 사용된 정도를 백분율(%)로 나타낸 것이다.
이를 확인함으로써 내가 테스트 코드를 작성하지 못한 부분이 존재하는지를 확인하며, 꼼꼼히 테스트를 작성할 수 있다.이에 대해 자세히 학습하고자 한다면 아래 블로그를 참고하면 좋을 것 같아 함께 첨부한다.IntelliJ 코드 커버리지 확인하기
코드 커버리지란?커버리지 측정 방법 🔎💡 먼저 이 글은 IntelliJ Ultimate 기준으로 작성되었음을 밝힌다.Test 패키지를 오른쪽 마우스로 클릭하고, More Run/Debug를 선택한 다음
Run 'Tests in '...' with Coverage를 클릭한다.그럼 인텔리제이는 코드를 분석하여 백분율로 코드의 Coverage를 출력해준다.더 정확한 Coverage 확인법 🕵️‍♂️인텔리제이는 브랜치 커버리지(Branch Coverage) 측정 방식을 지원하여,
위보다 더욱 정확하고 세밀하게 Coverage를 측정할 수 있도록 돕는다.💡 브랜치 커버리지(Branch Coverage)란?
브랜치 커버리지는 조건문(if, else if, else)에서 각 조건(branch)이 실행되었는지를 검증한다. 예를 들어 if(조건1 || 조건2 || 조건3)과 같은 조건식이 존재할 때,
3개의 조건에 대해 true인 경우와 false인 경우를 각각 측정한다고 알고 있다.⚙️ 설정 방법Test 패키지를 오른쪽 마우스로 클릭하고, More Run/Debug를 선택한 다음
Modify Run Configuration을 클릭한다.우측에 존재하는 Modify options를 클릭한다.Code Coverage 탭에 있는 Enable branch coverage and test tracking을 선택한다.그럼 이렇게 Branch Coverage에 대한 결과를 얻을 수 있는데,
이렇게 확인하니 아직 테스트 면에서 부족한 부분이 드러났다.🤔 그럼 문제의 위치는 어떻게 파악하는데?100%로 측정되지 않은 클래스에 접근하여 좌측 코드라인을 살펴보면 이렇게
녹색과 갈색이 표시되는 것을 확인할 수 있다.테스트되지 않은 부분은 갈색, 테스트되는 부분은 녹색으로 표시되는 것이다.이를 클릭해보면 테스트 코드 상에서 조건이 true였던 경우와 false였던 경우의 수가 출력되는데,
갈색인 부분은 결과값이 한 번도 true였던 적이 없었기 때문에, 이 클래스의 커버리지가 낮게 측정되었음을 확인할 수 있었다.마치며 💭이러한 과정을 통해 코드를 개선해나가면 더 안전하고 좋은 코드를 만들 수 있을 것이라고 생각한다.테스트 코드가 제대로 작성되었는 지, 확인하고 싶다면 이 방법을 통해 측정해보는 것을 추천한다![Java] 자바 정규표현식 활용 시, Pattern 객체를 만들어 사용하자 (feat. 우테코)잘 보구 갑니다 !좋은 정보 감사합니다!
제 인텔리제이에서는 Enable branch coverage and test tracking 대신 Use tracking 이라고 되어 있었습니다!
버전 차이인가봐요! ㅎㅎYou can rest assured with independent private Gurgaon escorts. You will not only satisfy your sexual desires but also complete every transaction with my help. I am always there to help my customers complete their contracts. Most of the clients I work with are professionals and they come to Gurgaon for business, so they are always looking for more than just an escort. With independent escorts, they can meet the perfect women who meet their needs as per their requirements.
https://www.jennygurgaonescorts.in
https://www.jennygurgaonescorts.in/manesar-escorts.html
https://www.jennygurgaonescorts.in/surajkund-escorts.html
https://www.jennygurgaonescorts.in/iffco-chowk-escorts.html
https://www.jennygurgaonescorts.in/palam-vihar-escorts.html
https://www.jennygurgaonescorts.in/rajiv-chowk-escorts.html
https://www.jennygurgaonescorts.in/udyog-vihar-escorts.html
https://www.jennygurgaonescorts.in/sohna-road-escorts.html
https://www.jennygurgaonescorts.in/dlf-Phase-3-escorts.html
https://www.jennygurgaonescorts.in/dlf-city-escorts.html
https://www.jennygurgaonescorts.in/dlf-golf-course-escorts.html
https://www.jennygurgaonescorts.in/hudda-city-center-escorts.html
https://www.jennygurgaonescorts.in/south-city-gurgaon-escorts.html
https://www.jennygurgaonescorts.in/sushant-lok-escorts.html
https://www.jennygurgaonescorts.in/neemrana-escorts.html
https://www.jennygurgaonescorts.in/bilaspur-escorts.html
https://www.jennygurgaonescorts.in/mahipalpur-escorts.html
https://www.jennygurgaonescorts.in/mg-road-escorts.html
https://www.jennygurgaonescorts.in/sikanderpur-escorts.html
https://www.jennygurgaonescorts.in/alwar-escorts.html
https://www.jennygurgaonescorts.in/bhiwadi-escorts.html
https://www.jennygurgaonescorts.in/rewari-escorts.html
https://www.jennygurgaonescorts.in/gurgaon-escorts-service.html",https://velog.io/@pgmjun/Java-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%ED%99%95%EC%9D%B8%EB%B2%95
velog dashboard 제작기 (1) - 벨로그 통계를 편하게 보고 싶어요 ㅠ,nuung,https://velog.velcdn.com/images/qlgks1/post/20a8e85d-b046-4a38-ad12-555fbda1c17c/image.gif,"velog dashboard 제작기 (1) - 벨로그 통계를 편하게 보고 싶어요 ㅠVelog Dashboard[ 해당 글은 ""velog-dashboard"" 프로젝트를 만들면서 기록한 DevLog 입니다! ]Velog Dashboard2021년 6월 5일년 조회수 통계 기능 도입 안내 글을 필두로 velog에 게시글 통계 (조회수) 기능이 배포되었다. 그리고 최근에 v3 발표가 되었다. 사실 velog 자체가 퍼포먼스 마케팅이나 inbound가 중요하게 생각되는 플랫폼이 아니라 자세한 조회수 또는 통계에 그렇게까지 니즈는 없으며, 이 부분이 오히려 타 플랫폼과 ""KISS(Keep it small and simple)"" 라는 점에서 차별점이 있지 않을까 라는 생각도 있다. 하지만 내가 궁금하다,, 그리고 은근 나 처럼 궁금해 하는 사람이 있다!,,1. Backgroundvelog 의 통계를 쉽고 빠르게, 편하게 보고 싶었다. 그리고 사실 다른 사람의 통계도 익명으로 global dashboard 로 만들어 보고 싶다. 후자는 너무 희망 사항점점 글을 기록 보다는 기술 + 컨텐츠 형식으로 만들다 보니까 자연스럽게 유입이 궁금해지고 반응 및 리액션이 궁금해졌다. 물 안들어오는데 노를 젓고 싶었다는 거다그래서 그냥 자체적으로 velog graphQL API 호출해서 보고 있었는데 이게 점점 귀찮다.. 깃허브에도 꽤 써드파티들이 보인다. 근데 산양되거나 FE(UI/UX) 가 고려된 프로젝트는 없다.. 그래서 그냥 ""내가 볼 HTML 퍼블리싱만 하자"" 가 판이 커져버렸다. 해당 글은 velog dashboard를 만드는 과정을 처음부터 기록한 글이다. 계속 글이 이어질 예정이다 :)2. 요구사항과 핵심 기능간단하게 아래 통계들을 한 눈에 볼 수 있었으면 했다. daily view counttotal view counttotal like count(list) each post view count / like count그리고 ""통계"" 는 ""단순 시계열 데이터"" 이다. 통계 시계열 데이터는 본질적으로 그 시간이 지난 데이터는 ""바뀌지 않는"" 값이고 log 데이터와 동일하다. 그래서 위 기능을 위해 과거의 데이터를 기록하면 자연스럽게 ""등락폭을 보고 비교"" 가 가능하다. 해당 count 값들의 ""전일자, 또는 특정일자 비교"" 기능데이터의 유동적인 시각화이렇게 데이터 수집, 보관과 데이터 시각화 가 핵심인 프로젝트이며 더 나아가 만약 다른 분들이 개인정보를 제외하고 재활용 하지 않는 범위의 통계의 비교 분석을 위한 수집 동의만 해주신다면, 위 기능들을 ""global"" 하게 비교 할 수 있게 된다. 3. 설계""핵심만 집중해서 먼저 만들기"", 로깅 및 수집, QE(Quality Engineering) & 테스트 코드, DevOps, SPoF, 프로비저닝 등의 미래는 최소한으로 고려만 하고 세팅하기!!1) 모델 중심 기능 설계핵심 기능만 버티컬하게 먼저 만들고 싶었다. 설계가 코딩의 80% 임은 격하게 동감하지만 기능적인 도메인을 구분하는 등의 치밀한 설계를 하지는 않았다. ""모델 중심, user flow 중심 설계"" 를 사전에 러프하게 했다. 다들 사이드 할때 고질적으로 먼 미래를 보게 되는 병이 있을 것이다.. 최대한 내려놓자, 내려놓고 시작해야 에자일하게 가능하다!!일단 데이터 수집을 위해서는 (velog의 graphQL 활용을 위해서는) velog의 auth token이 필요하다. 그래서 access token과 refresh token을 일단 저장해야 한다. 
token을 무단 수집하는 것은 악의적인 공격이 될 수 있고 보안적 위협이 맞다. 그래서 확실한 가이드 라인을 만들고 (수집 방법), 절대적인 오남용이 없게 (사용 목적) 명시 하고, 약관을 만들어야 한다. 당연히 공개된 정보외에 수집이 있으면 안되고 절대적으로 그 사람을 식별할 수 없어야 한다. 
token을 무단 수집하는 것은 악의적인 공격이 될 수 있고 보안적 위협이 맞다. 그래서 확실한 가이드 라인을 만들고 (수집 방법), 절대적인 오남용이 없게 (사용 목적) 명시 하고, 약관을 만들어야 한다. 당연히 공개된 정보외에 수집이 있으면 안되고 절대적으로 그 사람을 식별할 수 없어야 한다. 
나중에 언급하겠지만 그래서 절대 DB가 털리면 안된다. 다른건 다 됐고 DB가 나의 보안이 아닌 ""대중적으로 인증이 된 보안"" 하위에 있어야 한다. 
나중에 언급하겠지만 그래서 절대 DB가 털리면 안된다. 다른건 다 됐고 DB가 나의 보안이 아닌 ""대중적으로 인증이 된 보안"" 하위에 있어야 한다. 
token과 velog unique url (https://velog.io/@qlgks1 와 같이) 매핑되어서 다른 데이터와 참조되어야 한다. 
token과 velog unique url (https://velog.io/@qlgks1 와 같이) 매핑되어서 다른 데이터와 참조되어야 한다. 
velog의 post는 uuid를 가지고 있다. 이 uuid를 가지고 title과 통계정보를 저장해야 한다. 이렇게 post uuid값과 (1)에서의 velog unique url (FK) 둘 다 가지고 있으면서 index 되어야 한다. 그래야 통계 데이터를 빠르게 가져올 수 있다. 
velog의 post는 uuid를 가지고 있다. 이 uuid를 가지고 title과 통계정보를 저장해야 한다. 이렇게 post uuid값과 (1)에서의 velog unique url (FK) 둘 다 가지고 있으면서 index 되어야 한다. 그래야 통계 데이터를 빠르게 가져올 수 있다. 
포스트 자체의 시계열 데이터를 그대로 저장해야한다. 
포스트 자체의 시계열 데이터를 그대로 저장해야한다. 
velog의 통계 API는 통으로 전체 시계열 데이터를 던진다. 그래서 ""굉장히 무겁다."" 근데 어쩔 수 없고 생각한다. 개인적으로 이 통계 데이터 자체가 velog가 지향하는 점이 아니기 때문이라고 생각한다. 
velog의 통계 API는 통으로 전체 시계열 데이터를 던진다. 그래서 ""굉장히 무겁다."" 근데 어쩔 수 없고 생각한다. 개인적으로 이 통계 데이터 자체가 velog가 지향하는 점이 아니기 때문이라고 생각한다. 
그래서 최초 유저 (신규 토큰)의 경우 데이터 스크래핑 대기열에 추가가 되고, 워커에 의해서 스크래핑 되는 형태가 되어야 한다. 
그래서 최초 유저 (신규 토큰)의 경우 데이터 스크래핑 대기열에 추가가 되고, 워커에 의해서 스크래핑 되는 형태가 되어야 한다. 
그렇기 때문에 워커가 필요하고, 워커는 특정 데이터를 기반으로 계속해서 데이터 스크래핑을 하고 등록된 토큰은 폐기가 될 때 까지 (refresh 만료) 마지막 데이터 수집 시간을 기점으로 계속 스크래핑을 해야한다. 
그렇기 때문에 워커가 필요하고, 워커는 특정 데이터를 기반으로 계속해서 데이터 스크래핑을 하고 등록된 토큰은 폐기가 될 때 까지 (refresh 만료) 마지막 데이터 수집 시간을 기점으로 계속 스크래핑을 해야한다. 
따라서 ""데이터 수집의 결과 (인증 이슈, 4XX or 5XX 이슈)"" 와 ""마지막 스크레이핑 시도 시간"" 필드가 필요하다. 
따라서 ""데이터 수집의 결과 (인증 이슈, 4XX or 5XX 이슈)"" 와 ""마지막 스크레이핑 시도 시간"" 필드가 필요하다. 빠른 개발 속도와 저장하는 데이터의 특성, 거의 insert & select only data들이고 대량 업데이트에 많은 초점이 맞춰진 모델에 맞는 DBMS는 document DB라고 생각이 들었고, mongodb 를 선택했다.2) frontend원래 프레임워크 없이 vanilla js, HTML, CSS 조합을 좋아해서 ES6+ js & typescript 로 webpack + babel 통해서 퍼블리싱하려고 했는데 굳이? 라는 생각에 그냥 생짜 static file 에 nginx 조합 으로 서빙하려고 결심했다. 바벨링 해서 얻는 이득이 크지가 않다고 생각했다!..이번에 하면서 확실하게 나는 웹디자인 ""창조""의 능력은 많이 부족하다는 걸 다시 깨달았다. 웹디자인의 0에서 1을 만드는게 진짜 어렵다.. 갓터레스트 덕분에 남이 만들어둔 1에 살을 붙여서 3정도 겨우 만들었다 🥹
사용자가 access token / refresh token 을 넣어야 한다. 이게 여간 귀찮을 수 있기때문에 velog에 로그인한 브라우저의 경우 쿠키에서 access_token & refresh_token 값을 찾아 주도록 해야 한다. 
사용자가 access token / refresh token 을 넣어야 한다. 이게 여간 귀찮을 수 있기때문에 velog에 로그인한 브라우저의 경우 쿠키에서 access_token & refresh_token 값을 찾아 주도록 해야 한다. 
하지만 velog github repo를 보면서 깨달았는데 HttpOnly 로 세팅된 쿠키라 브라우저, client side에서는 함부로 접근할 수 없다! 그래서.. 직접 찾아서.. 뽑아내야한다 사용자가.. 끄훕 ㅠ^ㅜ
하지만 velog github repo를 보면서 깨달았는데 HttpOnly 로 세팅된 쿠키라 브라우저, client side에서는 함부로 접근할 수 없다! 그래서.. 직접 찾아서.. 뽑아내야한다 사용자가.. 끄훕 ㅠ^ㅜ그래도 velog는 거의 개발자 only blog라 직접 token들을 찾아서 넣을 수 있다고 생각하고, 직접 넣어야 한다..! UX를 향상시킬 수 있는 좋은 방법이 떠오르지 않는다.. 자칫하면 XSS 공격이 될 것 같다..
2. 요구사항과 핵심 기능 에서 언급한 모든 부분이 보여져야 한다. 데이터 수집, 스크레이핑이 비동기적으로 워커가 하니 기본적으로 polling이 필요하다. 그에 따라 dynamic rendering이 가능한 구조로 세팅해야 한다. 
2. 요구사항과 핵심 기능 에서 언급한 모든 부분이 보여져야 한다. 데이터 수집, 스크레이핑이 비동기적으로 워커가 하니 기본적으로 polling이 필요하다. 그에 따라 dynamic rendering이 가능한 구조로 세팅해야 한다. 
첫 색션에 수치화된 간단한 통계가 바로 보이고 날짜 구간을 세팅할 수 있는 등락폭 선 그래프가 바로 보이면 좋을 것 같다. 그 다음 색션에 게시글 리스트가 뜨면서 게시글 별 total view가 있으면 좋을 것 같다.
첫 색션에 수치화된 간단한 통계가 바로 보이고 날짜 구간을 세팅할 수 있는 등락폭 선 그래프가 바로 보이면 좋을 것 같다. 그 다음 색션에 게시글 리스트가 뜨면서 게시글 별 total view가 있으면 좋을 것 같다.
각 게시글을 클릭하면 게시글 별로 날짜 구간을 세팅할 수 있는 등락폭 선 그래프가 보이면 좋을 것 같다. 마치 지금 velog 통계에서 보여주듯이 말이다. 이 기능은 일단 최후순위다. 화면을 어떻게 배치하면 좋을까가 바로 떠오르지 않는다.. 🥲
각 게시글을 클릭하면 게시글 별로 날짜 구간을 세팅할 수 있는 등락폭 선 그래프가 보이면 좋을 것 같다. 마치 지금 velog 통계에서 보여주듯이 말이다. 이 기능은 일단 최후순위다. 화면을 어떻게 배치하면 좋을까가 바로 떠오르지 않는다.. 🥲완벽한 TBD다. velog 트랜딩 처럼 등록된 post의 daily traffic이 급상승하는 것을 노출할지, 그냥 간단한 전체 view를 노출할지,, 고민이다. 많은 조언 부탁드리겠습니다!! 😇🙆‍🙇‍3) backend & data scrapping단일 stack 유지를 위해 js를 계속 사용하고, node.js & express 로 핵심 model 들만 RESTFul 한 API로 제공하려고 한다. API 역시 1) 모델 중심 기능 설계 에서 나온 결론대로 따라갈 것 이다. 그리고 지속적인 데이터 수집은 python asyncio  & aiohttp 조합으로 비동기 및 코루틴으로 세팅하려고 한다. 즉 데이터 수집, 데이터 스크레이핑은 파이썬 워커를 만들어서 작동시키는 것 이다. 앞서 언급한대로 ""DB"" 가 가장 중요하고 mongodb를 사용하는 것에 결론을 내렸기 때문에, 가장 좋은 선택은 atlas cluster mongodb 를 사용하는 것이다! DB는 결정되었지만 역시 ""호스팅, 서버"" 가 문제다. 하꼬 개발자는 배포할 돈이 없다..! 개인적인 선호로 서버리스 대신 클라우드 서버에 온프램으로 직접 배포하고 싶다.. 일단 독립적인 기능적 면모로 API server & web server & worker server 로 최소 3개의 노드(간단하게 S/W server)가 필요하다. 하나의 docker compose 로 말아도 최소 2개 코어는 써야 마음이 편안한 구조다. 이래서 욕심을 줄여야 한다..솔직히 정말 현실적인 방안은 Netlify 와 같은 PaaS로 static file serving 하고api는 serverless 로 (AWS lambda 등) 제공하고DB & DBMS는 web SaaS로 관리가능한 cloud 사용하고worker 는 github action 을 사용하는 것이다. 이러면 worker를 제외하면 초기 구축만 잘하면 개발자로써 관리를 고민하는 포인트가 정말 거의 없다. ""하지만 그냥 내가 하나의 docker compose로 말아서 배포하고 싶다!""사실 하나의 서비스를 온프램에 가깝게 직접 구축하고 관리하는 것은 항상 즐겁다. 규모가 커지면 솔직히 혼자는 답이없지만, 토이플젝 서비스를 적어도 VM 기반의 cloud server에 올리고 관리하는게 즐겁다!Oracle CloudIBM Cloud그 외 중소 Cloud오라클은 프리티어 2개까지 가능하다. 각설하고 지금 시장에서 홍보하는 머기업 클라우드중에서는 프리티어 스팩이 굉장히 좋은 편이다. (왜냐면 2개까지 평생 무료를 밀고 있기 때문이다.) 하지만 내가 이미 다른 곳에서 너무 열심히 쓴..다..!이번 기회에 다른 라이트한 free cloud LaaS or PaaS 를 찾아보려고 했!! 는데... 검색 실력의 한계인가,, 오라클에 준하는 평생 무료 cloud server IaaS platform은 없는 것 같다. 일단 선택권이 없다. 내 욕심을 버리고 초기 오버헤드가 있지만 현실적인 방안을 선택하던지 vs IaaS 에 docker compose 로 말아올리고 직접 모든 부분을 관리하던지 중 후자를 확실하게 밀고 가야 한다!!IaaS 에 docker compose 로 바로가면 오버헤드가 크다고 판단했다. 1. 바로 사용가능하게 세팅되어 있는 (nginx와 pm2세팅 되어 있음!) 서버에 FE + BE(API) 만올리고, worker는 github action 사용하기바로 위 단계부터 일단 하고, 베타 론칭을 한 뒤에 볼륨 & 트래픽을 보고 판단한 뒤 IaaS 에 CI/CD를 구축하기로 했다. 2. docker image 구성하고 docker compose 로 구성, 모노레포를 통해 IaaS 에 SCP & SSH 기반으로 CI/CD 구성하기위가 베타 론칭이후 정식오픈에 활용할 구성이다. 4) infra 구상도위에서 언급한 단계별로 인프라 구상도가 살짝 바뀌는데, 아래는 첫 단계다. 왜 이렇게 대충 그렸니..이후 클라우드 서버에 통짜로 도커라이징된 친구들을 docker compose 로 배포하는 형태다. 서버 모니터링, 프로비저닝, 로깅 시스템, SPoF, CI & CD 등이 고려안된 아주 최초의 인프라 구조다. 일단 이대로 작업하고 하나씩 살을 붙이려고 한다. 일단 CDN, 최적화는 잊고, ""도메인"" 과 그에 따른 SSL 인증 (for https)는 꽤 중요하다. 내도메인.한국 이라는 곳을 사용할 것이다. 그리고 ssl 인증서는 역시 certbot 이다!이제 전체 간략한 그림은 다 잡았다! 앞으로 이어지는 글로 세부적인 디테일을 기록하려고 합니다! 부족함이 많은 설계이고 프로젝트라 많은 지적 부탁드리겠습니다! UI & UX에 대한 지적질도 많이 부탁드립니다. 언젠간 velog 정식 side로 dashboard를 위한, 하나의 메뉴 섹션으로 만들어지길 기도하면서 ㅎvelog dashboard 제작기 (2) - backend & worker (data scraping)👍🏻최곱니다너무 필요했던 서비스인데 이용해보니까 넘 편리해요
감사합니다!!만드신 프로젝트와는 별개로.. 기존 벨로그 통계 시스템이 너무 비효율적이였어서 (2편에서 얘기 하셨듯이) 데이터베이스를 느리게 만드는 현상이 발생했습니다.
게시물별 일일 통계는 잠깐 비활성화하고 조만간 개선하여 다시 도입하겠습니다.",https://velog.io/@qlgks1/velog-dashboard-%EC%A0%9C%EC%9E%91%EA%B8%B0-%EB%B2%A8%EB%A1%9C%EA%B7%B8-%ED%86%B5%EA%B3%84%EB%A5%BC-%ED%8E%B8%ED%95%98%EA%B2%8C-%EB%B3%B4%EA%B3%A0-%EC%8B%B6%EC%96%B4%EC%9A%94-%E3%85%A0
[front-end] 공통의 저주,sming.log,https://velog.velcdn.com/images/baby_dev/post/3dd9157e-1fca-4e08-a2be-0eb21a85c880/image.jpeg,"[front-end] 공통의 저주이번에 작성해볼 주제는 공통의 저주입니다.저도 프론트엔드 개발 초반에 빠졌던 이슈인데요. 처음 개발을 시작하면 dry원칙(don't repeat yourself) 이라는것을 많이 들으면서 개발을 진행할 것 입니다. 물론 이러한 원칙을 듣지않았더라도 반복되는 것은 공통으로 분리해야된다. 이정도는 많이 알게 되죠.이러한 공통을 지키겠다는 생각에 잡혀있을때 발생하는 문제(저주)에 대해서 알아봅시다.똑같은 ui의 input간단하게 이렇게 로그인, 회원가입 페이지를 기준으로 한번 보겠습니다.로그인에 존재하는 아이디, 비밀번호의 input과 회원가입에 존재하는 input들의 ui가 매우 유사한것을 볼 수 있습니다.그리고 이것을 보는 우리는 생각하죠. '공통 input을 이용하여 로그인, 회원가입 처리를 모두 해야겠다.'현시점에서는 나쁘지 않은 시도입니다. 크게 저 input에 기능이 없다면 큰 문제가 없기때문이죠.일단 간단하게 이렇게 input만 존재하는 공통이 있다고 가정해봅시다. (스타일도 적용된 상태라고 가정하겠습니다.)1️⃣ 첫번째 요청여기서 기획에서 회원가입할때만 validation을 달아주고 싶다고 합니다. 음 그러면 공통에서 inputType을 받아 회원가입인 경우만을 걸러낸다음, valid 한 값인지도 props로 받아서 처리하면 되겠네요.props에 2개의 값을 추가하고, 회원가입이고 isValid가 false일때만 저러한 메세지를 밑에 보여주기로 하죠.2️⃣ 두번째 요청만약 저 똑같은 인풋을 이용하여 이러한 포인트를 다루는 인풋을 구현한다고 가정해보겠습니다.(ui가 달라보일 수 있지만 실제로는 ui가 같다는 가정입니다.)포인트를 다루는 인풋이기에 현재 보유한 포인트까지만 입력할 수 있는 예외를 추가해야합니다. 그러니까 inputType에 point를 추가한뒤에 onChange의 이벤트핸들러에 pointform일때의 예외를 추가해봅시다.또, 포인트는 100,000P 이런형식으로 보여야하니 input의 format도 포인트일때는 다르게 변경해봅시다.🫠뭔가 이상하지 않나요?공통의 Input태그를 이용해서 로그인, 회원가입, 포인트 폼을 이용을 했습니다. ui가 동일하니 공통으로 잘 처리가 된듯하죠.하지만 뭔가 이상하지 않나요? 공통이긴하지만 공통이 너무나 많은 기능을 하고있죠. 그덕분에 불필요한 props, 그리고 많은 분기처리가 있는 모습을 볼 수 있습니다.만약 여기서 로그인의 기능이 추가된다면 어떨까요? 여기에 또 로그인에 대한 props, 분기처리가 또 들어가게 되겠죠?현재는 3개의 폼들로 예시를 들었지만 여기서 더 늘어난다면 훨씬 더 많은 분기처리를 하게 되죠. 3️⃣ ui변경 요청자 이제는 기능에 대한 추가가 아니라 ui변경 요청이 들어왔습니다. 포인트폼의 ui가 완전히 바꾼다고 가정해봅시다. 그렇다면 이 공통 Input으로 포인트 폼을 유지시킬 수 있을까요?ui가 달라졌기에 또 다른 input을 만들어야겠죠? 하지만 이미 포인트는 Input이라는 공통 태그에 강하게 묶여있기때문에 이 기능만 빼내기가 쉽지가 않아졌습니다.이 때문에 Input태그에 기능적 사이드 이펙트가 발생할수도 있습니다.👻 공통의 저주 👻그래서 오늘 얘기하고싶은 주제 공통의 저주 입니다.흔히 우리는 button, input 이러한 것을 공통으로 많이 만들고 합니다.그리고 개발을 한지 얼마안된상태로 '아 저런것들을 공통으로 빼서 관리하는구나' 라는 지식정도만을 알고 개발이 들어가게 되면 공통의 저주에 빠지게 되는것이죠.input을 공통으로 만드는게 좋다고하여 비슷한 ui들을 공통으로 맞추기 위해서 억지로 공통input태그에 props가 덕지덕지 붙게되고, 각 기능에 대한 분기처리가 넣어지는 아주 거대한 input창고가 완성되는것이죠.위의 예시는 비교적 눈치채지 쉬운 저주이지만 실제로는 눈치채지 못한채 저렇게 강하게 묶여있는 컴포넌트들이 꽤 있을 수 있습니다.저주는 해주해야지그래서 이 저주를 해결 하는 방법은 어떤것이 있을까요? 간단합니다. 여러분이 ui를 기준으로 공통으로 묶으려는 것을 도메인으로 바라보시면 됩니다.로그인 input과 포인트 input 2개의 도메인(관심사)은 다릅니다. 그렇기에 현재로써는 동일한 ui로 유지될 수 있지만 추후에 둘중에 하나에 기능이 추가될 수도 있고, 하나의 ui가 변할수도있습니다.그렇기 때문에 이런경우에는 LoginInput, PointInput 과 같은 식으로 동일한 ui를 가지지만 다른 컴포넌트로 분리를 해줘야합니다.흔히 똑같은 코드를 다른 컴포넌트에 적용을하면 반복을 하지마라 라는 철학으로 불편하게 느껴지기 때문에 저주에 걸리는것입니다.그래도 불편하시죠?LoginInput, PointInput 이렇게 2개로 쪼개시면 당연히 클린코드라는것을 아시는 여러분들은 불편하게 느껴지실겁니다. 똑같은 코드가 다른 컴포넌트에 있으니까요 👻물론 이것을 해결하는 방법이 존재합니다. 바로 Headless Component이죠.Headless Component는 말그대로 머리..없는 컴포넌트입니다. 좀 더 개발적으로 풀어 말하자면 기능을 가지지 않는 component입니다.그래서 공통되는 ui에 대해서 Headless Component로 반복을 없애며 각각 분리한 컴포넌트에서 custom hook으로 기능을 주입할 수 있습니다.한번 위의 예시를 Headless Component + custom hook으로 분리해볼까요?InputLoginInputPointInput결론이러한 관심사의 분리에 익숙하고 Headless Component + custom hook으로 많이 개발을 하신분들은 이러한 저주에 잘 걸리지 않지만 익숙하지 않은분들은 자주 걸리는 저주라고 생각됩니다.ui를 보고 공통으로 분리하지말고 도메인(관심사)를 보고 분리하자 이정도만 생각하신뒤에 개발을 하시면 잘 걸리시지 않을겁니다. 🐳 🐳[chrome-extension] chrome extension 으로 쿠키 다루기이글을 리액트 배우기 전에 봤더라면 ,,, ",https://velog.io/@baby_dev/front-end-%EA%B3%B5%ED%86%B5%EC%9D%98-%EC%A0%80%EC%A3%BC
주니어 프론트 개발자 첫 이직한 후기 풉니다.,bbahna.log,https://velog.velcdn.com/images/bbahna/post/6fea4b68-9725-428c-aed7-84893952e7b8/image.jpeg,"주니어 프론트 개발자 첫 이직한 후기 풉니다.Retrospect이직 준비와 이직을 하게 된 배경..퇴사 후 이직에 대해서는 사람마다 의견이 많이 나뉜다. 후회하니 무조건 회사를 다니면서 준비해야한다는 사람이 있고, 나와 같이 퇴사 후 준비해도 괜찮다고 생각하는 사람이 있다.물론 여기서 중요한 건 쉬는 동안 무엇을 할 지에 대한 계획과 이런 저런 말과 생각에서도 멘탈을 잘 지키는 것이 중요하다.난 준비가 어느정도 되었으면 퇴사를 한 후 이직을 준비해도 된다고 생각한다. 나의 경우는 퇴사를 하고 밀렸던 자바스크립트와 프론트엔드 기초를 잘 다질 수 있었으며, 이직 준비에 집중할 수 있었다. 나름 멘탈이 강하다고 자부하지만 회사를 다니며 가스라이팅을 당하는 기분을 견디기 힘들었다.나의 경우는 이직 준비를 퇴사 9개월 전부터 준비했다. 하지만 회사를 다니면서 하는 이직 준비는 회사 상황과 일에 따라 계획보다 자꾸 늦어졌다. 또한 스스로 부족하다고 많이 느꼈었다. 준비가 완벽히 되진 않았지만 어느정도 되었다고 느끼고, 나를 갈아가며 일 하는 느낌이 들었을 때 퇴사를 결심했다.결과적으로 3개월 후 재 취업에 성공했으며 준비한 기간과 퇴사에 대한 후회는 없다. 지금 1년이 되어가는 시점에서도 현 회사에 대해 꽤 만족 중이다.
회사를 고를 때, 나에게 중요했던 것들: 흥미있는 도메인 인가, 업무 분담이 잘 되어 있는가, 배울 점이 있는가(사수가 있는가)
물론 선택은 신중 해야한다. 하지만 너무 오래 고민하는 것도 문제이다. 이 시기에 가장 와 닿았던 말은 아래와 같다
회사를 고를 때, 나에게 중요했던 것들: 흥미있는 도메인 인가, 업무 분담이 잘 되어 있는가, 배울 점이 있는가(사수가 있는가)물론 선택은 신중 해야한다. 하지만 너무 오래 고민하는 것도 문제이다. 이 시기에 가장 와 닿았던 말은 아래와 같다행동하기 위해 고민한다. 행동하지 않는 고민인 걱정일 뿐이다. 고민은 짧게 행동은 빠르게.
무슨 일이든지 실제로 해보면 생각과는 다른 상황이 펼쳐지기에 열심히 고민하는 것으로 위안 삼으려 하지 말자.
행동하지 않는다면 그 고민의 시간은 의미없는 것이다.나는 고민을 하다 시간을 많이 흘려보낸 것 같아 위의 말이 참 와 닿았다. 고민과 생각으로 휩싸여 시간 보내기보다 일단 저지르는 것도 꽤 나쁘지 않을 수 있다 :)나의 프론트엔드 공부법html → css → javascript → react → store → api → typescript → git나의 프론트엔드 공부 순서는 위와 같다. 만들다 보면 늘어있다.개발은 특히나 강의만 열심히 듣는다고 실력이 느는 것이 아니다. 공부한 것을 적용해보면서, 즉 이것저것 만들어보면서 많이 느는 것이라 생각한다. 물론 좋은 강의를 들으면 기초를 쌓는 것에 도움이 많이 된다.한 때는 정답이 있는 것을 만들려는 생각도 했었지만 실무는 대부분 그렇지 않더라. 영어로 된 문서를 보면서 해결하는 경험, 버그를 발견하고 구글링하며 해결하는 모든 것들을 미리 경험해보는 것이 좋다. (이런저런 험한? 경험 하면서 개발에 대한 나의 적성을 경험하는 것도 좋다 ㅎㅎ) 실무는 대부분 매일 새로운 버그와 업무를 해결하는 하는 것이 일상이랄까?..포기하지 말기!처음부터 너무 어려운 프로젝트나 목표를 크게 잡으면 개발에 대한 흥미 자체를 잃어 포기하기가 쉽다. 처음엔 내가 재미를 느낄 만한 쉽고 재밌는 프로젝트를 몇 개 해보다보면 자신감도 붙고 더 오래할 수 있는 것 같다.또 요즘 느끼는 것은 오래된 시니어 개발자라고 해서 영어를 잘 아는 사람들은 적다는 것이다. (구글 번역도 많이 이용 하시더라 ㅎㅎ) 물론 어떤 것보다 영어를 제일 배워야하는 언어라고 말을 하기도 하고, 영어를 알면 개발하는데 정말 많은 도움이 된다. 하지만 영어를 잘 모른다고 해서 포기하거나 두려움을 가질 필요는 없다. 공부 하자!💪🏻도움이 된 자료프론트엔드 로드맵신입 프론트엔드 개발자가 되려면 무엇을 학습해야 하나요?벨로그 - 테오의 프론트엔드프론트엔드 엔지니어 커리어 로드맵: 주니어를 위한 3가지 전문성 트랙코딩애플 - 2023 '모던' 웹개발자 하려면 배울 것들이력서 작성주니어의 이력서 작성기이력서를 처음 썼을 때 여러 유명한 개발자 분들의 이력서를 참고하며 작성했다. 유명하신 분들의 이력서 노하우와 강의들을 보며 이력서 포인트는 개인의 스킬과 프로젝트 성과 위주, 구체적인 수치 위주의 간결한 작성이 핵심이라고 느꼈다. 해서 그 방법대로 이력서를 전부 작성하고 나니 주니어인 나에게는 무지 횡한 이력서가 완성되었다. ㅎㅎ..내가 봐도 나를 어필 하기엔 부족하다고 느꼈고 애매 하더라도 뭐든지 채워넣는게 맞겠다는 생각에 다른 주니어 개발자분들의 지원기나 이력서 자료들을 많이 찾아봤다. 그러던 중 유도근님의 이력서 작성법을 보며 무지 공감했다.주니어에겐 어떻게든 어필할 수 있는 많은 정보가 필요한 것이다. 아직 경험이 적고 내보일 만한 성과나 기여가 부족했기에 내가 어떤 사람인지 좀 더 설명하는 다른 자료들이 필요했다. 따라서 나의 방향성이나 추구하는 것들을 더 추가 하였고, 경험에 대한 내용을 좀 더 보완하였다.참고할 만한 자료개발바닥 신입 개발자 이력서워니 개발자 이력서 작성하기변정훈 이력서 작성구인본 이력서 작성eo 이력서 첨삭, eo 이력서 공개채용동향, 채용구조100개 넘는 공고를 보고 느낀점신입을 뽑는 곳은 정말 적다. 우리가 아는 좋은 기업일 수록 대부분 실력있는 개발자를 영입하기 위해 인재풀이나 경력직 공고을 그냥 열어놓고 기다리는 경우가 많았다. (큰 기업일 수록 신입을 많이 뽑아달라!)또한 여러 개발자 분들의 이력서 강의 들었던 것과는 다르게 자기소개서가 필수인 곳이 은근 많았다. (경력은 경력 기술서..) 커스텀하며 적었던 노션으로 된 이력서와는 다르게 큰 기업일 수록 자소서는 필수이며, 포트폴리오/경력증명서를 받는 곳도 정말 많았다. 코테 있는 곳도.. 준비할 게 정말 많다 🤦🏻‍♀️그리고 공고를 보는 것 만으로도 많은 도움이 되었다. 요즘 기술 트렌드를 알 수 있고 이력서를 써야 하는 방향도 알게 되었다. 개발 직무 외에 다른 IT 직무 어떤 것들이 있는지도 알게 되었고, 기업이 어떤 인재를 원하는지나, 프론트엔드는 어떤 업무를 하는지도 친절히 적혀있었다. ෆ 따라서 공고를 시간내어 보는 것도 추천한다. 다만 적당히만! 불안한 마음에 공고를 보는 것보다, 어느정도 내가 필요한 정보 파악이 되었다면 공고 보는 것을 그만하고, 자기소개서 한 줄이라도 더 쓰는게 더 실질적인 도움이 된다.이직 회고지원 결과!대략 완성 되었다고 느낀 이력서로 지원 가능한 곳을 대략 추리고, 9군데(7개는 인재풀이였고, 2군데는 2년 경력이지만 조건이 부족한데도 그냥 들이 밀었다 ㅎㅎ) 역시나 아쉬운 결과가..한 번의 쓴 맛을 맛 보고 내 이력서로 원티드/사람인 등에 60군데 적당한 프론트엔드 직무에 이력서를 뿌려봤다. 내 노션 이력서에 대한 반응을 보고 싶었다. 결과적으로 15군데 정도 연락이 왔다. 생각보다 연락이 꽤 와서 연습 삼아 면접을 2군데 정도 보고 이후엔 정말 가고 싶은 곳만 찾아서 면접을 보았다. 면접 보면서 멘탈도 좀 털리고 자신감도 꽤 잃었었다. 현 회사 면접을 봤을 땐 느낌도 좋았고 도메인도 마음에 들어서 이직하기로 결심했다.난 나에게 정한 시간과 준비 상황에 맞춰 여의도 쪽의 핀테크 앱 개발 프론트엔드 직무의 스타트업에 취업을 했다. 무엇보다 이전 회사와는 다르게 기획과 디자인이 있으며, 프론트엔드 직무에 집중할 수 있었던 점이 만족스러웠다. 또한 핀테크라는 익숙하고 흥미있는 업종과 코드 리뷰의 문화와 부족한 점은 가르쳐 주시면서 성장하는 느낌을 받게 했던 좋은 사수분을 만났다. 입사 3개월 후 떠나셔서 슬펐다 ㅜ마무리아직은 부족함이 많은 주니어 개발자이지만, 이 글이 취업/이직 준비하는 누군가에겐 도움이 되기를 바랍니다. 다들 행복해~~모소대나무는 4년동안 겨우 3cm를 성장하다, 5년이 되는 해부터 매일 30cm씩 성장하여 6주만에 15m가 넘는 거대한 나무가 된다. 지금 당장은 자라고 있지 않아 보이지만, 수백 m의 뿌리를 뻗치고 있었던 것이다.
2023 계획에 대한 회고. 1년 뒤의 목표를 세우는 것이 큰 의미가 있을까 🤔잘 읽었습니다.글 잘 읽었습니다! 노력하신만큼 좋은 결과를 얻으셨네요!👍 마지막 모소대나무 글도 감명깊었습니다!☺️",https://velog.io/@bbahna/2023-trunover
모노레포 과연 필요할까?,endmoseung.log,https://velog.velcdn.com/images/endmoseung/post/80509b80-f147-40e0-8505-b8baedb7c6b7/image.png,"모노레포 과연 필요할까?얼마전 회사 테크톡 시간에 모노레포에 대한 발표를 진행했습니다.
이 기술이 우리 회사의 상황과 가지고 있는 자원으로 적용 가능한가에 대한 고민을 해봤으며 그떄의 발표를 각색해서 작성하려고 합니다.모노레포란모노레포란 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 개발 전략우선 모노의 어원을 들여다보면 “모노(mono)는 ""하나""를 의미하는 그리스어의 접두사이다.“, 즉 여러개의 레포지토리를 하나의 레포지토리로 운영하는것이다.
프론트엔드 레포지토리로 쉽게 예를들면 현재 여러개의 서비스가 있고 디자인시스템 레포지토리가 있는데 모노레포를 이용하면 디자인시스템을 install 하지 않고 직접 모듈을 전해받아 사용 가능하다.멀티레포(폴리레포)멀티레포 희망편멀티레포는 현재 대부분의 애플리케이션을 개발하는 표준적인 방법이다. 업계는 팀의 자율성이라는 큰 이유 때문에 이 방식을 선호한다. 팀은 애플리케이션 개발의 라이프사이클을 스스로 결정하기를 원한다.
예를들어 프론트엔드 개발자 A는 혼자 B라는 서비스를 개발했고 독자적인 eslint 규칙, 아키텍쳐, 배포 파이프라인, 패키지를 가지고 있었다.
물론 이렇게 개발하면 독자적인 레포지토리에서 본인의 입맛에 맞게 프로젝트를 생성하고 유지보수가 가능하기에 유리할때도 있다.멀티레포 절망편예를들어 사내에 디자인 시스템이 도입됐다.
실제로 디자인시스템이 도입돼서 UI의 일관성과 작업효율이 늘어났다.
하지만 디자인시스템을 도입하니 문제가 생겼다. 이를 어떻게 관리하냐인데 예를들어 사내에 디자인시스템을 적용하여 서비스를 운영중인게 5개이다.
멀티레포환경에서 도입하기 위해 각각 install 해야하고 만약에 디자인쪽에서 요구사항이 생겨 특정 컴포넌트의 변경이 생긴다면 개발자는 현재 디자인시스템을 사용하고있는 레포지토리마다 모두 방문해서 디자인 시스템을 버젼 업 해주어야 하며 이는 현재 깃플로우 전략에 의해 3번의 Pull Request가 있어야하므로 3 * 현재있는 레포지토리수 만큼의 Pull Request를 날려서 Merge해야한다.
하지만 이는 휴먼에러를 일으킬 확률이 있으며 만약에 하나의 레포지토리를 까먹었다면 우리 서비스를 마주할 유저는 서로 다른 UI를 경험하게 될것이다.디자인 시스템 뿐만 아니라 사용중인 서비스마다 라이브러리의 버젼 또한 모두 다르다.
이 외에도 프론트엔드에서는 비즈니스로직을 재사용하기 쉽게하기 위해 CustomHook을 사용하는데 하나를 개발하면 그 hook이 필요한 모든 레포지토리에 가서 해당 코드를 추가해야한다.
혹은 린트룰을 하나 바꾸고 모두 적용해야 한다면 이 또한 번거로울 것이다.모노레포는요?앞선 거의 모든 문제를 모노레포를 사용한다면 해결할 수 있다.
우선 하나의 거대한 레포지토리 안에 Workspace를 만들고 각각의 레포지토리를 넣어준다.
그리고 상위 레포지토리에서 서비스에 필요한 의존성을 설치해주고, 각각의 서비스에서 필요한 작업을 해준다. design-system에서는 각 서비스에 필요한 UI를 개발해주고 필요하다면 스토리북을 이용하여 Test를 해준다. 그리고 필요한 비즈니스 로직은 core에서 처리해준다.
이러면 각각의 서비스는 필요한 UI와 비즈니스로직을 각각의 패키지에서 주입받아 실제로 필요한 코드를 남길 수 있다.
이렇게 하면 패키지 관리도 수월할 뿐더러 관심사의 분리도 가능해져서 더욱 좋은 코드 생산이 가능하다.

이 외에도 모노레포를 사용하면 CI/CD 파이프라인을 상당히 단순화 시킬수 있다. 공통 의존성 관리: 모노레포에서는 여러 프로젝트가 공통으로 사용하는 라이브러리나 도구를 한 곳에서 관리할 수 있습니다. 따라서 이러한 의존성을 업데이트하거나 변경할 때, 각 프로젝트를 개별적으로 수정하고 테스트할 필요가 없어지므로 CI 과정이 단축됩니다.테스트 최적화: 모노레포에서는 코드 변경사항을 감지하고 관련된 테스트만 실행하는 것이 가능합니다. 이는 전체 테스트를 실행하는 것에 비해 시간을 크게 단축시킵니다. 이러한 최적화는 CI 서버의 리소스를 효율적으로 사용하게 해줍니다.버전 관리 용이성: 모노레포에서는 전체 프로젝트의 상태를 한 번의 커밋으로 기록할 수 있습니다. 이는 배포 과정에서 각 프로젝트의 호환성 문제를 예방하고, 배포 버전을 추적하고 관리하기 쉽게 만들어줍니다.원자적 커밋: 모노레포를 사용하면 여러 프로젝트에 걸친 변경사항을 하나의 커밋으로 처리할 수 있습니다. 이는 CI/CD 파이프라인에서 여러 프로젝트를 동시에 빌드하고 테스트하는 복잡성을 줄여줍니다.문서화와 코드 리뷰 통합: 모노레포를 사용하면 문서화와 코드 리뷰를 한 곳에서 진행할 수 있습니다. 이는 프로젝트 간의 일관성을 유지하고, 리뷰와 피드백 과정을 효율화시킵니다.5번은 코드 리뷰 통합에서는 장점일 수 있으나 적절한 PR 컨벤션이 없다면 서비스들이 혼재돼 오히려 혼란을 초래할 수 있다.모노레포 단점CI 속도 저하 가능성 → 하나의 레포지토리의 크기가 매우 커지기 때문형상 관리 경험 저하 → 하나의 레포지토리에서 Pull Request가 올라오기 때문에 만약 동시에 다른 서비스를 여러개 작업중인 상태라면 적절한 Pull Request Template이 존재하지 않는다면 혼선이 있을 수 있음 모노레포 어떻게 하는데?좋을것만 있을것 같은 모노레포 그럼 어떻게 개발해야하는지에 대해서 설명하겠다.
뭐든지 기술은 거저 주는것이 아니다.모노레포 통합 후 서비스별 배포 전략모노레포에 대한 학습 비용모노레포로 변경하기 위한 마이그레이션 비용모노레포를 통합 후에 각 서비스는 어떤식으로 배포해야할지 정해야하며 기존에 멀티레포로 돼있는 각 레포를 모노레포로 마이그레이션 하는 비용이 들고 이를 학습하기 위한 비용까지 들기에 결코 쉬운 작업이 아니다.모노레포 패키지 매니저아래는 2021,2022년 패키지 매니저 사용률이다.

. Lerna가 1등에서 3등까지 내려왔고 터보레포가 무서운 기세로 점유율이 올라오고 있다. 필자도 터보레포로 공부했는데 사용하기 편리했고 Vercel에서 만들었다.
Apps폴더에서 필요한 서비스들을 두고 packages에서 필요한 UI나 비즈니스 로직을 처리한다. 자세한건 터보레포 공식홈페이지를 확인 바란다.모노레포 레퍼런스정말 많은 기업에서 모노레포를 도입해 서비스를 개발하고 있다.무신사아고라채널톡토스배민콴다화해이 외에도 많은 기업에서 모노레포를 도입했다.우리회사에서의 모노레포우리회사에서는 선생님과 학생이 만나 화상수업을 진행하는 호두클래스라는 서비스가 있다.
이 서비스는 학생과 선생님이 만나 공통된 UI에서 각자 다른 권한을 가지고 서비스를 진행하며 선생님은 백오피스쪽에서 접속하고 학생은 회사 플랫폼쪽에서 접속을 하여 각각 필요한 api 통신을 처리한다.(ex: 수업 시작, 수업 종료, 슬랙 알림 등)상당히 비슷한 UI 구조를 가지고 있고 권한에 따라 UI가 다른게 특징인데 그럼에도 중복되는 레이아웃이나 컴포넌트가 많이 있다.
만약 우리 서비스에서 모노레포를 도입할 수 있다면 적절한 관심사 분리와 함께 중복되는 UI로직을 제거할 수 있을거라고 생각했다.
첫번째 사진이 기존 아키텍쳐이고 두번째 사진이 모노레포를 도입하게 된다면 적용될 아키텍쳐이다.
그리고 회사가 성장하는만큼 다양한 신규 서비스들을 런칭할 예정인데 서비스가 많아지고 복잡할수록 모노레포가 가진 장점때문에 꼭 필요할거라 생각했다.하지만 아직까지는 여러서비스에서 공통적으로 가지는 기능은 많지 않고 디자인시스템은 현재 NPM배포로 적용하고 있다. 그리고 모노레포같은 기술은 수단일뿐이기에 팀원들과의 충분한 협의를 거쳐 필요한 시점에 도입해야된다는 결론이 났다.읽어보면 좋을것들모노레포 적용부터 Yarn berry까지 - 화해모노레포 이렇게 좋은데 왜 안써요? - 무신사팀워크 향상을 위한 모노레포 시스템 구축 - 콴다모노레포 - 마이크로 아키텍쳐를 지향하며  - 그린랩스터보레포로 모노레포 개발 경험 향상하기  - 라인모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편 - 네이버Rush로 프론트엔드 모노레포 도입기 - 밀당(영어 에듀테크)테크톡으로 성장하기왜 모승은 스타트업에서 개발자를 하고있나요?lerna 보다 turborepo가 엄청 좋더라고요",https://velog.io/@endmoseung/%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-%EA%B3%BC%EC%97%B0-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C
우리 팀이 Zustand를 쓰는 이유,도라에몽의 코드빵 🍞,https://velog.velcdn.com/images/greencloud/post/9e09a48a-1b09-4720-9d1d-6c1d44b5dcef/image.JPEG,"우리 팀이 Zustand를 쓰는 이유부스트캠프 그룹프로젝트에서 우리 팀은 Zustand를 사용하게 되었다.
이 글은 우리 팀이 어떤 이유로 Zustand를 선택하게 되었는지에 대한 이야기이다.여기서는 상태관리 라이브러리 중 왜 Zustand를 골랐는지에 포커스를 두어 이야기하기 때문에, 왜 상태관리 라이브러리를 써야 하는지에 대해서는 설명하지 않는다.
프로젝트 특성상 상태관리 라이브러리를 굳이 쓰지 않아도 될 지도 모른다.
이 글을 읽기 전에, 현재 프로젝트에 상태관리 라이브러리가 꼭 필요한지에 대해서 먼저 생각해보길 추천한다.먼저 우리가 상태관리 라이브러리를 선택할 때 가장 기본적으로 고려한 것은 아래와 같다.학습에 큰 어려움이 없어야 한다.가벼워야 한다.우리에게는 6주간의 시간밖에 없기 때문에, 상태관리 라이브러리 학습에 많은 시간을 투자할 수 없다.
또 Three.js같은 3D 라이브러리를 사용하기 때문에 렌더링 성능이 굉장히 중요하다.
그래서 상태 관리 라이브러리도 최대한 가벼운 것으로 선택하여 애플리케이션 성능에 주는 영향을 줄이고자 했다.출처: npm trendsnpm trends에서 검색한 상태관리 라이브러리 최근 1년간 다운로드 수이다.
우리 팀은 이 5개의 라이브러리를 후보로 두고 고민을 시작했다.각자가 모두 다른 특성을 갖고있지만, 이 5가지는 상태 관리 유형에 따라 크게 3가지로 분류할 수 있다.
이들의 특징을 간단하게 알아보자.🍞 상태 관리 유형 분류1. Flux 방식Redux, Zustand가 이 유형에 속한다.
이 유형은 Flux 아키텍처 모델을 기반으로 하는 중앙 집중식 상태 관리 솔루션이다.
Flux 패턴에서 데이터는 단방향으로 흐른다.출처: https://haruair.github.io/flux/docs/overview.htmlAction이 발생하면, Dispatcher에서 이를 해석한 후 Store에 저장된 정보를 갱신하고, 그 결과가 다시 View로 전달된다.이 유형은 상태를 한 곳에 모아 관리하고 싶을 때 적합하다.
하지만 상태를 중앙 집중화하기 때문에 상태 업데이트가 많거나 복잡할 경우 성능 문제가 발생할 수 있다.2. Proxy 방식MobX가 이 유형에 속한다.
이 유형은 상태를 프록시 객체로 래핑한다.
그래서 직접 객체를 다루지 않고, 프록시를 통해 작업을 수행하게 된다.
이 특성 덕분에 중첩된 객체의 상태 관리에 유용하다.
일반적으로 중첩된 객체의 상태를 관리하려면 상태를 복사하고, 속성을 수정하고, 수정한 상태를 다시 덮어쓰는 과정이 필요하다.
하지만 여기서는 프록시를 통해 상태를 직접 변경할 수 있기에 중첩 객체 상태 관리가 훨씬 수월하다.하지만 상태를 직접 변경하는 방식을 사용하기 때문에 오히려 불변성을 엄격하게 지키는 것이 어려워질 수도 있다.
또 프록시 개념에 익숙하지 않다면 다루기 어려울 수 있고, 특히 디버깅에 어려움을 겪을 수 있다.그리고 이 유형은 객체지향 프로그래밍과 잘 맞다.
물론 함수형 프로그래밍과 함께 사용할 수 있긴 하지만, 이들의 핵심 원칙과 기능은 객체 지향 프로그래밍의 원칙과 더 잘 어울린다.3. Atomic 방식Recoil, Jotai가 이 유형에 속한다.
이 유형은 전체 상태를 원자 (Atom)으로 나누는 것을 추구한다.
원자는 업데이트 가능하고 구독 가능한 상태의 단위이며, 이들은 서로 다른 부분에서 독립적으로 사용된다.
때문에 상태 관리의 모듈화가 쉽고, 코드의 재사용성이 높아진다.
하지만 상태가 단순하고 재사용의 필요성이 낮을 경우, 이 모델을 사용했을 때 오히려 더 복잡해질 수 있다.4. 우리의 선택이러한 특징들을 고려했을 때, 우린 먼저 Proxy 방식을 1차로 탈락시켰다.
프로젝트 특성상 중첩된 객체가 많을 것 같지도 않았고, 결정적으로는 객체지향 친화적이라는 점이 마음에 들지 않았다.
물론 함수형 프로그래밍 방식에도 충분히 적용할 수 있다.
하지만 그렇게 하면서까지 이 유형을 써야 할 필요성을 느끼지 못했다.남은 것은 Flux 방식과 Atomic 방식이다.
이 둘의 가장 큰 차이점은 상태를 관리하는 방식이다.
Flux 방식은 모든 상태를 한 곳에서 관리한다.
여러 컴포넌트에서 공유되는 상태를 관리하는 데 효과적이다.
Atomic 방식은 각 상태를 각각 다른 곳에서 독립적으로 사용하고 관리한다.
상태의 모듈화와 재사용성이 중요할 경우 사용하면 좋다.우리 프로젝트의 경우 그렇게 복잡하거나 관리할 상태가 많지 않다.
굳이 상태를 작은 단위로 쪼개서 관리할 필요까지는 없다고 판단했다.
그래서 일단은  Flux 방식 쪽으로 마음이 더 기울었다.그래도 Flux 방식 라이브러리 하나, Atomic 방식 라이브러리 하나를 골라 비교해보기로 했다.🍞 Redux vs ZustandFlux 방식에 속하는 Redux와 Zustand를 비교해보자.
먼저 아까 봤던 npm trends 자료를 보면 Redux의 다운로드 수가 압도적으로 높다..출처: npm trends하지만 Redux는 다른 라이브러리들에 비해 학습곡선이 가파르다.
짧은 기간동안 프로젝트를 진행하는 우리 상황에서, 배워야 할 내용과 작성해야 할 코드가 많은 Redux는 적합하지 않다고 판단했다.
또 간단한 프로젝트에 무겁고 복잡한 Redux를 쓰는 것은 '굳이?'라는 생각이 들었다.
더 깊게 생각할 것도 없이 Redux는 후보에서 제외해버렸다.🍞 Recoil vs JotaiAtomic 방식에 속하는 Recoil과 Jotai를 비교해보자.
Recoil은 Facebook에서 개발한 상태 관리 라이브러리이다.
Jotai는 Recoil의 Atomic 패턴에서 영감을 받아 만든 라이브러리라고 한다.
그래서 둘의 사용 방식이 상당히 비슷하다.결론적으로는 Jotai가 더 낫다고 판단했다.
첫 번째 이유는 번들 사이즈 차이이다.
Jotai는 830kb, Recoil은 2.17mb로 꽤나 큰 차이가 난다.또한 활발한 업데이트가 이루어지고 있는 Jotai에 비해 Recoil은 업데이트가 많이 더딘 편이다.이외에 몇 가지의 차이점이 있었지만, 결과적으로는 Recoil보다 Jotai가 훨씬 단순하며 가볍다는 사실 때문에 Jotai를 선택하게 되었다.
둘의 사용 방식에 큰 차이가 없기 때문에 어떤 라이브러리가 더 간단한 상태 관리에 적합한지에 포커스를 두고 고민했다.🍞 Zustand vs Jotai마지막으로 이 둘을 비교해서 최종 결정을 하기로 했다.
본격적으로 비교해보자.Zustand와 Jotai의 기술적 차이가 궁금하다면 아래 내용을 읽어보는 것을 추천한다.
https://github.com/pmndrs/jotai/issues/131. 다운로드 수먼저 npm trends 다운로드 수를 다시 보자.
여기서 Redux는 제외했다.출처: npm trends다운로드 수는 Zustand가 압도적이다.
새 라이브러리를 학습하는 우리의 입장에서는, 사용자가 많을수록 학습자료가 많을 것이기에 장점으로 느껴졌다.2. 번들 사이즈Zustand는 187kb, Jotai는 830kb이다.
Zustand가 훨씬 가볍다는 것을 알 수 있다.3. Provider 사용 유무Jotai는 보통 Provider로 애플리케이션을 감싸야 하는 반면, Zustand는 Provider를 사용할 필요가 없다.
사실 이 부분은 양쪽 모두 장단점이 있기 때문에, 확실한 장점이라고 할 수는 없겠다.4. Vanilla JS 지원 여부Jotai는 React만 지원하지만 Zustand는 Vanilla JS도 지원한다.
하지만 우리는 React를 사용하기 때문에 이 부분도 큰 장점으로 다가오지는 않는다.5. 상태 관리 방식가장 큰 차이점이다.
사실 위의 내용들보다는 이 부분이 가장 중요한 것 같다.
Zustand는 중앙집중화된 하나의 store 안에 여러 상태들이 담기는 반면, Jotai는 각각의 상태가 atom 형식으로 흩어져 있다.
Top-down 방식과, Bottom-up의 차이이다.위에서 언급했듯이 우리의 프로젝트에서는 상태를 여러 곳에서 관리하는 Atomic보다는 한 곳에서 관리하는 Flux 방식이 더 맞다고 생각했다.그리고 이런 논리적인 이유들을 떠나서, 팀원 모두 Flux 방식의 라이브러리 사용 경험이 없었기 때문에 Zustand가 더 매력적으로 느껴지기도 했다.결론적으로 우리는 Zustand를 사용하기로 했다.이 글에서는 각각의 라이브러리 특성을 깊게 공부하기보다는, 라이브러리 간 차이점을 중심으로 비교해보는 시간을 가졌다.
비교되는 두 라이브러리 모두 가지고 있는 기능이나, 우리 프로젝트와 크게 관련 없는 기능 중에는 아예 언급하지 않은 것들도 있다.
더 깊게 알아보고싶은 라이브러리가 있다면 공식문서를 통해 공부해보는 것을 추천한다.참고자료React: different types of state managementFlux OverViewWeb:React Flux 패턴React 상태관리 라이브러리 리뷰RecoilJotaiZustandReact 최신 상태관리 라이브러리 비교하기차세대 상태관리 라이브러리, Jotai vs ZustandHow is jotai different from zustand?JS로 자전과 공전을 구현할 수 있다고? 너와의 추억을 우주의 별로 띄울게이유를 가지고 라이브러리를 선택한다는 점이 인상깊네요!!
보통의 팀 규모의 프로젝트에서는 개인의 선호로 인해 라이브러리가 선택되는 경우가 많은데 적절한 이유를 들어 조사를 하신점이 멋지네요! 응원합니다!!Zustand는 로고가 귀여워요 🐻키야 많이 알아보셨네요 역시 울팀 리더상태관리 라이브러리를 관성적으로 쓰게 되는데 많이 깨닫고 갑니다 ㅎㅎ.. Zustand가 Vanilla JS 서포팅하는건 좀 신기하네요..!왜 상태관리에 Zustand를 사용했냐는 질문을 준비하고 계신 분들은 이 글을 읽으면 될 정도로 정리가 잘 되어 있네요!👍중앙화된 스토어에 플럭스 패턴, 쉬운 사용법은 리덕스 툴킷에도 포함되는 내용인데요? 다만, 프레임워크 문법이 훨씬 쉽다는 점에서 많은 뉴비들이 선택하기에 좋을 것 같습니다.
persist같은 옵션도 있으니 나중에 사용해보세요.
https://velog.io/@yunsungyang-omc/Zustand-%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-Zustand-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0
굳이 따지자면, 서버 상태를 관리해주는 라이브러리의 등장으로 클라이언트 사이드의 상태관리 포션이 많이 줄은게 사실이고 경우에 따라서는 상태관리도 컨텍스트나 리듀서로도 충분히 관리할 수 있다고도 생각해요react를 사용하면서 상태관리에 대한 복잡함과 어려움을 경험하고 상태관리 라이브러리를 알아보고 있었는데 정리가 잘 되어 있어서 너무 도움이되었습니다!
프로젝트의 규모와 특성을 고려하여 라이브러리를 선택하고 장단점을 비교하시는 부분들에서 배울 것이 많았네요.그룹 프로젝트를 진행하는 과정에서 저는 경험이 많지 않아 대표적으로 많이 언급되는 Redux와 Recoil 중 러닝 커브가 낮은 Recoil을 선택했는데, 조금 더 생각봐도 좋았을 것 같다는 생각이 드는 글이었습니다. 좋은 글 감사합니다! 추후 상태관리 라이브러리 선택에 있어서 참고하겠습니다 :)",https://velog.io/@greencloud/%EC%9A%B0%EB%A6%AC-%ED%8C%80%EC%9D%B4-Zustand%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0
(번역) HTMX 살펴보기 및 React와 비교하기,hwangse.log,https://velog.velcdn.com/images/sehyunny/post/f5dd7c85-5b24-455b-a5ac-592206c892b8/image.webp,"(번역) HTMX 살펴보기 및 React와 비교하기FE 번역글원문 : https://www.builder.io/blog/htmx-vs-react한동안 동적 웹 앱 세계에서 리액트와 같은 거물급 프레임워크가 큰 비중을 차지했습니다. 이들은 강력하지만 때때로 과하다는 느껴질 수 있습니다. 특히 프런트엔드가 익숙하지 않은 백엔드 개발자라면 더욱 그렇습니다.이제 HTMX라는 새로운 관점이 등장했습니다. 이는 전통적인 서버 사이드 렌더링과 오늘날의 클라이언트 사이드 상호 작용 사이의 간극을 원활히 메워줍니다. 엄청난 양의 자바스크립트를 다룰 필요 없이 HTMX가 해줄 것입니다.HTMX에 대해 궁금하신가요? 이 글에서는 HTMX의 기능과 장점을 파헤치고, HTMX가 유명한 프레임워크 사이에서 어떻게 몸집을 키웠는지 알아보겠습니다. 시작해 보죠!웹 개발의 거친 여정옛날 옛적에, 웹 페이지는 그저 정적인 디스플레이에 불과했습니다. 변경하고 싶은 부분이 생기면 어떻게 하냐고요? HTML을 직접 업데이트해야 했습니다. 그러나 웹의 욕구는 점점 커져서 더 많은 동작과 상호작용을 갈망하게 되었습니다. 이때, 자바스크립트가 등장하여 페이지가 생동감 넘치는 무대로 바뀌었습니다.2000년대에는 AJAX가 판도를 크게 바꾸었습니다. 더 이상 전체 페이지를 새로 로드할 필요가 없어졌습니다. 매끄럽고 끊김 없는 동작이 중요해졌습니다. 그리고 JQuery는요? AJAX를 더 멋지고 개발자 친화적으로 만들었습니다.다음 장은 프레임워크입니다. 리액트와 뷰, 그리고 앵귤러가 등장했고, 구조뿐만 아니라 백엔드 개발자들에게 몇 가지 수수께끼도 함께 가져왔습니다. 요즘은 어떨까요? HTMX와 같은 도구가 새로운 시대를 암시합니다. 그들은 ""왜 두 시대의 장점을 합치지 않나요?""라고 질문합니다. HTMX는 역동적이고 매끄럽지만, 무겁지 않습니다. DjangoCon 2022의 화젯거리를 확인해 보세요. HTMX에 관한 설명핵심적인 특징: HTMX가 특별히 신경쓰는건 무엇일까요? 바로 단순함을 유지하는 것입니다. 익숙한 HTML을 버리지 않고도 웹 마법에 깊이 빠져들 수 있습니다. HTMX는 자바스크립트 정글에 깊이 들어가지 않고도 HTML에 살을 붙이고, 역동성을 발휘하는 속성을 더합니다.마법: 별도의 스크립트 주문이 없습니다. HTMX는 일반 HTML 태그에 사용자 정의 속성을 추가합니다. 사용자가 버튼을 탭 하면요? 짠, 이 속성들은 AJAX와 유사한 요청을 보냅니다. 서버가 응답하면 HTMX는 쉽고 부드럽게 콘텐츠를 새로 로드합니다. 로직은 서버 사이드에서 처리하여 클라이언트 사이드 스크립트에 약간의 여유를 제공합니다. 다른 것과 잘 호환됨: 그리고 HTMX는 여러분이 즐겨 사용하는 기술과 잘 호환됩니다. 장고 혹은 플라스크를 주로 사용하시나요? HTMX는 바로 적용되어 전체적인 리모델링 없이도 사용할 수 있습니다.간결하고 깔끔함: 거대한 프런트엔드 프레임워크가 지배하는 세계에서, HTMX가 멋진 대안으로 떠오르고 있습니다. 리액트나 뷰와 같은 거물급 프레임워크의 일자리를 뺏으러 온 게 아닙니다. HTMX는 이들의 무거운 기능이 부담스러울 때 간단한 선택지가 될 수 있습니다. 영상 링크 : https://youtu.be/r-GSGH2RxJsHTMX: 상호작용에 대한 재고HTMX의 등장으로, 웹 상호작용의 역동성이 변화했습니다. HTMX는 전형적인 자바스크립트 설정에 대한 부담감 없이, 여러 기능을 제공합니다.  활발한 동적 콘텐츠사용자가 콘텐츠를 탐색할 때, HTMX는 전체 페이지를 새로 로드하지 않고 매끄러운 피드를 보장합니다.화면 뒤에서의 폼 제출폼은 백그라운드에서 동작하여 중요한 페이지의 특정 부분만 업데이트합니다.자동 업데이트실시간 점수 업데이트와 같은 기능은 어떨까요? HTMX에는 자동 업데이트 기능이 있기 때문에 수동으로 새로고침할 필요가 없습니다.UI 요소 관리팝업 모달을 포함한 UI 컴포넌트를 보다 쉽게 제어할 수 있습니다.서버 로직 동기화카트에 아이템 추가와 같은 기능은 서버 사이드 동작과 원활히 동기화할 수 있습니다.위 예제로부터 확실해졌습니다. HTMX는 간소화된 접근 방식을 제공합니다. 서버 사이드 메커니즘과 완벽히 통합되고 빽빽한 클라이언트 사이드 스크립트를 최소화합니다. 기술적인 부분: HTMX 작동 방식HTMX의 잠재력을 최대한으로 활용하려는 개발자에게 HTMX의 동작 방식을 이해하는 것은 중요합니다. HTMX의 구문은 표준 HTML을 연상시키지만, 기저의 과정을 통해 차별점을 갖습니다.HTML을 확장HTMX의 핵심은 HTML의 기능을 확장하는 것입니다. HTMX는 표준 HTML 태그에 추가했을 때, 별도의 스크립트 없이 동적인 동작을 가능하게 하는 새로운 속성을 도입했습니다. 서버 통신HTMX은 서버와 원활하게 통신합니다. hx-trigger로 명시된 이벤트가 발생했을 때, HTMX는 AJAX 요청을 생성합니다. 서버는 이 요청을 처리하여 다시 응답을 보냅니다.  콘텐츠 전환HTMX의 뛰어난 기능 중 하나는 서버 응답에 따라서 페이지의 콘텐츠를 전환할 수 있다는 점입니다. hx-swap 속성은 콘텐츠 전환이 발생하는 방식을 지정합니다.  이벤트 핸들링HTMX은 강력한 이벤트 시스템을 제공합니다. HTMX가 콘텐츠를 업데이트한 이후에 사용자 정의 로직을 실행하기 위해서 htmx:afterSwap과 같은 특정 이벤트를 수신할 수 있습니다. CSS와 통합HTMX는 CSS와 원활히 작동합니다. 예를 들어, CSS 애니메이션을 활용한 로딩 스피너를 보여주기 위해 hx-indicator를 사용할 수 있습니다.에러 핸들링AJAX 요청 실패와 같은 에러가 발생했을 때, HTMX는 이를 원활하게 처리하는 동작을 제공하여 부드러운 사용자 경험을 보장합니다. 익숙한 HTML 구문과 강력한 동적 기능을 결합하여, HTMX는 인터랙티브 웹 애플리케이션을 제작하는 과정을 간소화하였습니다. HTMX는 프런트엔드와 백엔드 개발 사이의 격차를 해소하여 기존 프레임워크의 복잡성 없이 풍부한 사용자 경험을 제공할 수 있습니다.HTMX 채택의 장점1. 간단함과 학습 곡선가파른 학습 곡선을 필요로 하는 포괄적인 프런트엔드 프레임워크와 달리, HTMX는 보다 직관적인 접근 방식을 제공합니다. HTML을 확장하여 개발자에게 친숙한 환경을 제공하므로, 쉽게 시작할 수 있습니다.2. 성능 향상HTMX의 가벼운 특성은 더 빠른 페이지 로드를 의미합니다. 사용자들은 거대한 자바스크립트 라이브러리나 프레임워크를 로드하는 오버헤드 대신, 더 빠른 상호작용과 지연 시간 단축을 경험할 수 있습니다.3. 클라이언트 사이드 복잡성 감소HTMX는 동적 동작의 대부분을 서버 사이드 로직으로 전환하여, 클라이언트 사이드 로직의 복잡성을 줄였습니다. 그 결과, 코드가 더 깔끔하고 유지보수하기 용이해졌습니다. 4. 원활한 통합HTMX는 기존의 기술과 쉽게 통합할 수 있도록 설계되었습니다. 서버 사이드 프레임워크를 사용하든 데이터베이스를 사용하든, HTMX는 대대적인 개편 없이도 바로 적용할 수 있습니다. 5. 사용자 경험 향상HTMX는 전체 페이지 새로고침 없이 콘텐츠를 동적으로 업데이트할 수 있는 기능을 통해, 더 부드러운 사용자 경험을 보장합니다. 전환이 매끄럽게 이뤄져서 사용자는 어색한 페이지 새로고침에 의해 방해를 받지 않습니다.6. 비용 효율적인 개발HTMX의 단순함과 광범위한 프런트엔드 개발에 의존도가 낮아지는 효과를 고려했을 때, HTMX를 사용하는 프로젝트는 종종 더 빠르게 완성할 수 있어 개발 시간과 자원에 필요한 비용을 절약할 수 있습니다.7. 백엔드 개발자를 위한 역량 강화이제 백엔드 개발자는 사용자 인터페이스 제작에 더 적극적인 역할을 수행할 수 있습니다. HTMX를 사용하여 프런트엔드 스크립트를 깊게 탐구하지 않고도 인터랙티브 UI 컴포넌트를 제작할 수 있습니다.효율성, 성능, 그리고 사용자 경험이 가장 중요한 세상에서, HTMX는 웹 개발자들에게 매력적인 선택지로 떠오르고 있습니다. HTMX는 강력함과 단순함의 균형 잡힌 조합을 제공하여 오늘날 웹 개발의 중요한 도구로 자리 잡고 있습니다. HTMX와 React: 비교 분석웹 개발 영역에서는 종종 도구와 프레임워크를 서로 비교하여 강점, 약점 및 최상의 사용 사례를 결정하는 경우가 많습니다. 현재 리액트가 프런트엔드 생태계의 왕으로 군림하고 있기 때문에 HTMX와 리액트를 많이 비교할 것으로 예상합니다. 이들은 동적 웹 애플리케이션 생성이라는 유사한 최종 목표를 가지고 있지만 접근 방식은 다릅니다.영상 링크 : https://youtu.be/wIzwyyHolRs철학과 접근 방식HTMX: HTML을 확장하여 마크업에 직접적으로 동적 기능을 추가할 수 있습니다. 단순함과 서버 사이드 로직을 활용하는 것에 초점을 맞추고 있습니다.React: 사용자 인터페이스를 생성하기 위한 자바스크립트 라이브러리입니다. 리액트는 컴포넌트 기반의 구조와 효율적인 업데이트를 위한 가상 돔을 강조합니다.학습 곡선HTMX: HTML 중심의 접근법을 통해 특히 기존 웹 개발에 친숙한 사람들에게 완만한 학습 곡선을 제공합니다.React: 강력한 기능을 제공하지만, JSX, state, props와 같은 자체적인 개념을 갖고 있기 때문에 초보자에게는 부담스러울 수 있습니다.성능HTMX: HTMX는 가볍기 때문에 초기 페이지 로딩 속도가 빨라지고, 클라이언트 사이드 처리가 줄어듭니다. React: 가상 돔 덕분에 효율적으로 UI 업데이트를 진행할 수 있어 잦은 업데이트가 필요한 큰 규모의 애플리케이션에 적합합니다.통합HTMX: 기존의 서버 사이드 기술과 원활히 동작하도록 설계되어, 많은 프로젝트의 플러그 앤드 플레이(plug-and-play) 해결책이 됩니다.React: 다방면으로 활용할 수 있지만, 특히 자바스크립트 생태계 내에서 생성되지 않은 프로젝트의 경우 통합에 추가적인 설정이 필요합니다.사용 사례HTMX: 본격적인 기능을 갖춘 프런트엔드 프레임워크의 오버헤드 없이 동적 상호작용이 필요한 프로젝트에 가장 적합합니다. 또한 광범위한 자바스크립트 없이 상호 작용 기능을 추가하려는 백엔드 개발자에게도 이상적입니다.React: 단일 페이지 애플리케이션(SPA)과 복잡한 상태 관리를 통해 풍부하고 동적인 사용자 경험을 제공하는 프로젝트에 가장 적합합니다.커뮤니티와 생태계HTMX: 인기가 높아지고 있지만, 기존 프레임워크 커뮤니티에 비해 아직은 작은 규모입니다. 그러나 양질의 지원과 자원을 제공합니다.React: 방대한 커뮤니티, 수많은 서드파티 라이브러리, 광범위한 자원을 자랑하며 전 세계 많은 개발자 사이에서의 인기있는 선택지입니다.단점과 트레이드오프긍정적인 측면만 있는 것은 아닙니다. 모든 도구에는 장단점이 있습니다. 다음은 시작하기 전에 고려하고 알아두어야 할 몇 가지 중요한 사항입니다. 새로운 접근 방식이 아닙니다. 본질적으로 Knockout, Alpine 그리고 이와 유사한 ""JS-in-HTML"" 접근 방식의 변형입니다.제한된 도메인 특화 언어(DSL)로 인해 편의성이 떨어집니다. 구문 하이라이팅, 린팅 그리고 정적 분석에 대한 지원을 받기 어렵습니다. 타입 안정성이 없습니다.같은 이유로 디버깅 또한 어렵습니다.결론적으로 이 접근 방식은 자바스크립트를 약간만 사용하면 되는 소규모 프로젝트에 적합합니다. 우리는 수년 전에 바닐라와 jQuery로 이미 같은 경험을 했으며, 확실한 이유로 인해 떠났습니다.HTMX와 리액트 모두 그들만의 장점이 있습니다. 둘 중에 하나를 선택하기 위해선 프로젝트의 요구 사항, 도구에 대한 팀의 친숙도, 그리고 원하는 개발 경험을 고려해야 합니다. 리액트가 프런트엔드 세계에서 지배적인 위치를 차지하고 있지만, HTMX는 더 간단하면서도 강력한 대안을 제공하면서 틈새시장을 개척하고 있습니다. 영상 링크 : https://youtu.be/DuGyH5RvfbY향후 웹 개발에서 HTMX의 역할HTMX는 웹 개발에서 점점 주목받고 있으며, 잠재적인 영향은 다음과 같습니다.오래된 것과 새로운 것의 혼합
HTMX는 서버사이드 렌더링의 안정성과 오늘날의 클라이언트 사이드 상호작용의 묘미를 결합하여 균형을 맞춥니다. 동적이면서 효율적인 웹 프로젝트를 위한 매력적인 선택지입니다.포용적인 개발
모든 개발자가 프런트엔드 복잡성을 깊게 탐구하는 것은 아닙니다. HTMX는 백엔드 중심의 개발자가 자바스크립트 프레임워크와 씨름하지 않고 동적인 웹을 설계할 수 있도록 플랫폼을 제공합니다.성능을 우선시
속도를 중시하는 온라인 사용자들을 위해 HTMX의 간소화된 접근 방식은 신속하고 민첩한 웹 플랫폼 개발을 촉진합니다. 신선한 트렌드 채택
웹 세계는 끊임없이 진화하고 있습니다. HTMX의 적응형 설계는 새로운 기술 및 표준과 잘 조화될 준비가 되어있음을 의미합니다. 접근 방식의 변화 가능성
HTMX에 대한 관심 증가는 웹 개발 방식의 잠재적인 진화를 암시합니다. 많은 프런트엔드 프레임워크가 이미 자리를 잡았지만, 간단하고 효율적인 도구들이 기세를 몰아가고 있습니다.커뮤니티 확장
HTMX가 많은 팔로워를 모으기 시작하면서 자연스럽게 커뮤니티도 성장하고 있습니다. 이는 추가적인 자원, 확장 및 협업을 위한 발판을 마련하여 웹 개발에서의 유용성을 높일 수 있습니다.요약하자면, HTMX는 웹 개발 분야에서 유망한 수단으로서 두각을 나타내고 있습니다. 이는 현재 개발자의 요구에 부응하며 동적인 웹사이트를 설계하기 위한 혁신적인 방식을 제공합니다. 앞으로의 영향력은 진화하는 커뮤니티와 그들의 창의적인 애플리케이션에 따라 크게 달라질 것입니다.주요 시사점끊임없이 변화하는 웹 개발 환경에서, HTMX는 독자적인 영역을 확보하고 있습니다. HTML을 개선하여 개발자에게 익숙한 설정을 제공하고 웹 상호작용성을 더 쉽게 탐구할 수 있습니다.웹 페이지의 속도가 사용자 경험을 정의할 수 있는 시대에 HTMX는 가벼운 특성으로 빛을 발하며, 빠른 로드와 부드러운 상호작용을 보장할 것입니다. 또한 백엔드 개발자들의 역량을 강화하여 프런트엔드 영역을 더 깊이 탐구할 수 있게 하고, 서버 로직과 클라이언트 동작 사이의 넓은 간극을 메워줍니다.프런트엔드 세계가 리액트나 뷰와 같은 거인들에 의해 사로잡힌 것 같지만 HTMX는 신선한 접근 방식을 제공합니다. HTMX는 다른 길이 있음을 보여주면서 동적 웹 앱 개발을 위해서는 많은 자바스크립트가 필요하다는 통념에 도전합니다.HTMX는 최신 도구 그 이상일 수 있습니다. HTMX는 웹 개발 방식의 진화 가능성을 암시하며, 복잡한 기술과 사용자 경험 사이의 섬세한 균형을 강조합니다. 커뮤니티가 성장하고 HTMX가 더 많이 채택되면서, 미래의 웹 개발을 어디로 이끌지 누가 알 수 있을까요?  한 가지 확실한 건 그들의 트위터 (X) 계정이 심각한 밈 게임 중이라는 것입니다...(번역) 이상한 자바스크립트: 왜 every()는 빈 배열에 true를 반환할까?",https://velog.io/@sehyunny/a-first-look-at-htmx-and-how-it-compares-to-react
[번역] 위키피디아의 총 차단 시간(TBT) 단축하여 300밀리 초 더 빠르게 만들기,not working,https://velog.velcdn.com/images/typo/post/6c8e4628-7e9c-4a20-8b5b-47f28db7de66/image.png,"[번역] 위키피디아의 총 차단 시간(TBT) 단축하여 300밀리 초 더 빠르게 만들기translations.zip이 글은 원저자 Nicholas Ray의 허락을 받아 300ms Faster: Reducing Wikipedia's Total Blocking Time을 한국어로 번역한 글입니다. :)클릭했는데 느리게 반응하거나 스크롤이 끊기는 웹사이트로 인해 불편을 겪은 적이 있으신가요? 이러한 성능 결함으로 다음과 같은 문제가 발생할 수 있습니다.분노의 클릭이탈률 증가 및 전환율 감소검색 엔진 순위의 하락3년 넘게 위키피디아 모바일 사이트는 저사양의 디바이스에서 페이지를 로드 중에 실행이 600밀리 초 이상 소요되는 자바스크립트 문제로 고생했습니다. 이로 인해 낮은 성능의 기기에서는 사용자의 상호작용이 사실상 원활하게 이루어지기 어려웠습니다.이 글에서는 제가 해당 작업의 실행 시간을 약 50% 감소시키기 위해 취한 몇 가지 방법들을 소개해 보겠습니다.총 차단 시간: 오래 걸리는 작업이 중요한 이유600밀리 초의 동기식 자바스크립트 실행은 그리 길지 않은 시간처럼 들릴 수 있지만, 페이지 로딩 중에 자바스크립트가 실행되기 시작할 때 사용자가 버튼을 클릭하려는 상황을 상상해 보세요. 브라우저의 메인 스레드에서는 한 번에 하나의 작업만 처리될 수 있기 때문에 사용자는 다음 일련의 단계들이 완료되어야 시각적으로 업데이트를 확인할 수 있습니다.600밀리 초의 자바스크립트 작업이 실행됩니다.관련된 클릭 핸들러 작업이 실행됩니다.페이지를 시각적으로 업데이트하는 데 필요한 렌더링 단계를 수행합니다.앞의 작업(1)이 길어지면 시각적 업데이트를 생성하는 클릭 핸들러의 실행이 지연될 수 있습니다.각 단계는 시간을 소요하고, 사용자는 시각적으로 업데이트하는 데 100밀리 초보다 오래 걸리는 모든 인터랙션을 느리다고 인식할 수 있습니다. 따라서 구글은 50밀리 초 이상 걸리는 모든 작업을 ""긴 작업""으로 간주하며, 이러한 작업들은 사용자 입력에 대한 페이지의 반응성에 영향을 미칠 수 있습니다. 이를 측정하는 ""총 차단 시간""(TBT)이라 불리는 지표가 개발되었습니다.50밀리 초 이상 걸리는 작업이 두 가지(80밀리 초와 100밀리 초) 있습니다.총 차단 시간(TBT)이란 무엇인가?TBT는 First Contentful Paint(FCP)와 Time to Interactive(TTI) 사이에 브라우저 메인 스레드에서 오래 걸리는 작업들에 의해 차단되는 부분의 합을 측정합니다. ""차단되는 부분""이란 각 오래 걸리는 작업의 첫 50밀리 초 이후의 시간을 의미합니다.아래 예시에서 TBT를 계산해봅시다.초반 80밀리 초가 걸리는 작업은 기준인 50밀리 초보다 30밀리 초 더 소요되므로 TBT에 30밀리 초가 추가됩니다.두 번째 작업은 50밀리 초보다 짧은 30밀리 초만을 소요하므로 TBT에 영향을 미치지 않습니다.마지막 100밀리 초 작업은 50밀리 초보다 50밀리 초 더 오래 걸리므로 TBT에 50밀리 초를 더합니다.TBT는 각 오래 걸리는 작업들이 50밀리 초보다 초과하여 소요하는 시간의 합이므로, 위 예시에서 TBT는 30밀리 초와 50밀리 초를 더해 80밀리 초가 됩니다.평균적인 모바일 하드웨어에서 테스트한 결과에 기반하여, 구글은 웹사이트의 TBT가 200밀리 초를 초과하지 않는 것을 권장하고 있습니다. 그러나 위키피디아는 단 하나의 작업만으로도 구글에서 권장하는 TBT 한도의 약 3배 이상인 600밀리 초를 소요했습니다.TBT를 어떻게 개선할 수 있을까요?총 차단 시간을 줄이는 방법TBT를 줄이기 위해서는 다음과 같은 항목을 따라야 합니다.FCP와 TTI 사이에 메인 스레드에서 수행하는 작업을 줄이세요.동일한 양의 작업을 수행하되, 오래 걸리는 작업을 50밀리 초를 초과하지 않는 작은 작업으로 분할하세요.이 글에서는 첫 번째 항목에 초점을 맞추어 TBT를 개선합니다.1단계: 불필요한 자바스크립트 제거하기메인 스레드에서 HTML 파싱, 페인트, 가비지 컬렉션 등 여러 작업이 실행되지만, TBT 문제의 주요 원인은 긴 자바스크립트 실행인 경우가 많습니다. 즉, 자바스크립트는 웹사이트 속도를 저하시키는 가장 빠른 방법입니다.위키피디아의 모바일 웹사이트를 프로파일링 한 결과, _enable 메서드가 실행 시간의 대부분을 차지한다는 것을 발견했습니다. 이 메서드는 모바일 웹사이트의 섹션을 확장/축소하는 동작을 초기화합니다. 또한 _enable 메서드 내에서 jQuery의 .on(""click"") 메서드의 호출이 느리다는 것을 프로파일링 결과에서 알 수 있었습니다..on(""click"") 호출은 콘텐츠의 거의 모든 링크에 클릭 이벤트 리스너를 부착하여 클릭한 링크에 해시 프래그먼트가 포함된 경우 해당 섹션이 열리도록 했습니다. 링크가 거의 없는 짧은 기사의 경우 성능에 미치는 영향은 미미했습니다. 하지만 ""미국""과 같은 긴 기사에는 4천 개 이상의 링크가 포함되어 있어 저사양 기기에서 200밀리 초 이상의 실행 시간을 초래했습니다.더 심각한 것은 이 동작이 불필요했다는 점입니다. hashchange 이벤트를 구독하는 코드가 이미 클릭 이벤트 리스너가 호출한 것과 동일한 메서드를 호출하고 있었습니다. window의 location이 이미 링크의 대상을 가리키고 있지 않는 한, 링크를 클릭하면 checkHash 메서드가 클릭 이벤트 핸들러와 hashchange 핸들러에서 각각 한 번씩, 총 두 번 호출되었습니다.따라서 이 경우에 가장 좋은 접근 방식은 이 자바스크립트 블록을 제거하고 거의 동일한 기능을 유지하면서 메인 스레드에서 약 200밀리 초를 확보하는 것이었습니다.프로파일링 할 때는 항상 가장 많은 시간이 소요되는 곳을 확인하세요. 그런 다음 최적화하거나 더 나은 방법으로 제거할 수 있는 코드가 있는지 확인하세요.웹사이트 속도를 높이는 가장 빠른 방법은 자바스크립트를 제거하는 것임을 기억하세요.2단계: 기존 자바스크립트 코드 최적화하기추가적으로 성능을 검토한 결과, initMediaViewer 메서드가 실행되는 데 약 100밀리 초가 걸리는 것으로 나타났습니다. 이 메서드는 콘텐츠의 각 섬네일에 클릭 이벤트 리스너를 연결하여 섬네일을 클릭했을 때 미디어 뷰어가 열리도록 했습니다.1단계의 링크 예시와 마찬가지로, 각 섬네일에 이벤트 리스너를 연결하는 것은 확장성이 떨어집니다. 위키백과 문서 편집자들은 수천 개의 이미지가 포함된 문서를 만들 수 있으며 실제로 그렇게 생성되고 있습니다. 이 코드 블록을 실행하면 이미지가 많은 페이지에서 실행하는 데 100밀리 초보다 훨씬 오래 걸리고 페이지의 TBT가 증가할 수 있습니다. 이 문제에 대한 다른 접근 방식은 무엇이 있을까요?바로 이벤트 위임을 활용하는 것입니다.이벤트 위임은 여러 요소의 공통되는 상위 요소에 이벤트 리스너 하나만을 연결하는 강력한 기술입니다. 여러 요소를 추가할 수 있는 사용자 생성 콘텐츠를 다룰 때는 이벤트 위임을 사용하는 것이 더 효율적인 경우가 많습니다. 이 기술은 이벤트 버블링을 활용하여 다음과 같이 동작합니다.컨테이너 요소에 이벤트 리스너를 연결합니다.이벤트 핸들러의 event 파라미터를 사용하여, 이벤트의 출처를 찾기 위해 event.target 프로퍼티를 확인합니다. 상위 요소를 확인하기 위해 event.target.closest(selector) API를 사용할 수도 있습니다.이벤트의 출처가 우리의 목표 요소 또는 그의 하위 요소인 경우 이벤트를 처리합니다.변경된 코드는 다음과 같습니다.이 경우에서 제가 수정한 것을 정리하면 다음과 같습니다.모든 이미지가 포함된 컨테이너 요소에 하나의 클릭 이벤트 리스너를 연결하도록 initMediaViewer 메서드를 수정했습니다.onClickImage 메서드에서 ev.target.closest(selector) API를 사용하여 클릭 이벤트가 섬네일이나 섬네일 요소의 하위 요소에서 발생한 것인지 확인했습니다. 섬네일에서 발생한 경우면 이벤트를 처리하고, 그렇지 않은 경우 얼리 리턴을 실행합니다.이 수정 작업으로 인한 결과는 어땠을까요?결론위에서 1단계, 2단계로 설명한 최적화를 단계별로 두 번의 배포를 통해 프로덕션 환경에 적용했습니다.위키피디아의 합성 성능 테스트 데이터에 따르면, 실제 Moto G(5) 휴대전화에서 테스트 해보니 첫 번째 배포에서는 TBT가 약 200밀리 초 감소했으며, 두 번째 배포에서는 약 80밀리 초 개선되었습니다. 전반적으로 이 두 단계를 통해 Moto G(5) 휴대전화와 같은 기기에서 긴 기사를 방문했을 때 TBT가 300밀리 초 가까이 감소했습니다.영어 위키피디아의 ""스웨덴"" 문서를 방문했을 때, Moto G(5) 기기에서의 위키피디아의 합성 성능 테스트 결과위키피디아의 실제 유저 모니터링(RUM) 결과를 통해서도, 오래 걸리는 작업의 시간이 개선되었다는 것을 알 수 있었습니다.p95 인도 사용자의 실제 사용자 모니터링 그래프가 로드 이벤트 전에 발생하는 긴 작업의 시간이 대략 200밀리 초 개선되었음을 보여줍니다.저사양 기기에서는 여전히 권장 한도를 초과하는 작업이 있지만, 지금까지 이루어진 진전은 상당한 수준입니다. TBT를 더 크게 줄이려면 지금의 작업을 더 작은 작업으로 쪼개야 할 수도 있습니다.이 경험을 통해 알 수 있는 것은 작고 특정한 최적화를 통해 상당한 성능 향상을 달성할 수 있다는 것입니다. 코드의 특정 부분을 제거하거나 최적화함으로써, 사소한 변화가 웹사이트의 전반적인 성능에 상당한 영향을 미칠 수 있습니다. 이는 모든 기기에서 작동하는 민첩한 브라우징 환경을 제공하는 것이 항상 복잡하고 광범위한 코드 베이스 변경이 필요한 것은 아니라는 점을 상기시켜 줍니다. 때로는 작은 변화가 가장 큰 차이를 만들기도 합니다.[번역] 웹 콘텐츠 속 숫자의 접근성 높이기",https://velog.io/@typo/300ms-Faster-Reducing-Wikipedias-TBT
Flutter Study Weekly Memoirs Week 1,ttungnyang2.log,https://velog.velcdn.com/images/ttungnyang2/post/7b82bd1f-3ba1-49ba-ba5a-839adc4a49c2/image.jpeg,"Flutter Study Weekly Memoirs Week 1Flutter Study1주차 주간회고록기간: 2023.11.13 (월) ~ 2023.11.15 (수)🤟 핵심 3줄 요약플러터 2기 시작!게으름 피우지 말고 다시 복습하기!첫 벨로그 글 작성!✨ 이번주 목표 ✨틱톡 #10까지 다 듣기클론 코딩하기🎁 칭찬하고 싶은 점, 좋았던 점퇴사 안 한 것.플러터 2기 다시 신청한 점.💧 고치거나 버려야 할 점, 아쉬웠던 점퇴사 안 한 것.자꾸 늦게 자는 것.복습 안 하려고 하는 점.💻 일일 스프린트 작성과제 제출하기틱톡 강의 듣기책 읽기과제 제출하기틱톡 강의 듣기책 읽기복습하기분리수거 하기틱톡 강의 듣기복습하기주간회고록 제출하기🧑‍💻 이번주에 배운 내용Dart에서는 상수가 되는 시점에 따라 컴파일 타임과 런 타임 상수 변수고 구분된다는 점.컴파일 타임 상수 변수 - const런 타임 상수 변수 - final널 안정성 (널 포인트 예외)객체가 null일 때 발생할 수 있는 오류를 코드 작성 시점에서 점검 가능해서 안전한 코드 작성할 수 있다.널 허용List 자료형의 collection for, collection if 기능이 좋다. 코드가 많이 간결해졌다.
더 익숙하게 사용하고 싶당.🤷 질문그러면 어떨 때 널 허용을 사용하는 것이 좋을까?
값을 알고 있는 변수면 그냥 사용 안 하고 애매하면 걍 다 사용하면 되나,,?💁 기억에 남는 것플러터 1기 때 헨리 님이 벨로그에 주간회고록 작성한 거 보고 탐나서 손민수 함.

스터디가 언제 시작인지 모르고 과제부터 확인하는 꼰대훈
스터디가 언제 시작인지 모르고 과제부터 확인하는 꼰대훈Flutter Study Weekly Memoirs Week 2저도 부자가 되고 싶어요.퇴사 하지 않으신 것에 축하드리고 위로드립니다. 화이팅!
주간회고록이 너무 재밌어용멋지다 역시 파워블로거다보니 마크다운의 신같네요모든 것이 적절하네요! 역시 짱멋져와! 멋져요. 너는 매우 퇴사하다 다른 blo왜g 안 써주십니다.플러터 재도전 넘나 멋져요^_^앞으로 재미난 주간회고록 기대하겠슴돠~!!2기를 시작하는 심기선양을 응원하러 달려왓슴다
지치지말고 화이팅!!!짤 고르는 실력 엄청나시네요ㅋㅋㅋㅋㅋ! 10주간 재밌게 써주세요!칭찬하고 싶은 점, 아쉬웠던 점 둘 다 ""퇴사 안 한 것."" 있는 게 킬포네요 ㅋㅋㅋWe are offering a wide range of supreme quality Cisco products and services for the preparation of the Cisco certification exams.
https://www.certstraining.com/TDS-C01-exam.html
https://www.certstraining.com/tds-c01-exam.html
https://www.certstraining.com/C_S4CAM_2302-exam.html
https://www.certstraining.com/c-abapd-2309-exam.html
https://www.certstraining.com/c-abapd-2309-exam.html
https://www.certstraining.com/sy0-601-practice-test
https://www.certstraining.com/md-102-study-guide
https://www.certstraining.com/uipath-adav1-exam.html
https://www.certstraining.com/fsmtb-certifications-questions.html
https://www.certstraining.com/c-thr83-2205-exam.html이번엔 환급받으시길...ㅋㅋㅋㅋㅋㅋ플러터 잼납니다 화이팅~믓지십니다...!",https://velog.io/@ttungnyang2/Flutter-Study-Weekly-Memoirs
[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 3주차,oneoneone.log,https://velog.velcdn.com/images/oneoneone/post/959bc814-755e-4e3b-95ed-2c1eaa0e9067/image.png,"[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 3주차동료들은 다 아는 정보, 나만 모르지 않게 만들어주는
일일일에서 한 주간 개발자들이 많이 읽은 상위 10개의 아티클들을 소개합니다.📌  나와 비슷한 동료들이 많이 읽은 아티클을 보고 싶다면?
>> '일일일 - 개발' 오픈채팅방 (참여 코드 : oneone1)01. [SaaS] 프론트엔드 개발자가 API를 설계하는 이유✅ 안녕하세요, 힐링페이퍼 백엔드 엔지니어 Eddy입니다. 저는 현재 힐링페이퍼에서 미용 의료 병원용 SaaS 제품을 개발하고 있습니다. 이번 글에서는 KOS팀에서 병원 관리 소프트웨어 KOS(이하 KOS)를 개발하면서 새로 도입한 인터페이스 정의 언어를 이용한 인터페이스 관리 전략에 대해 소개합니다.https://oneoneone.kr/content/e8f4978102. 젯브레인스 문서화 도구 ‘라이터사이드’ 뜯어보기✅ 개발자에게 커뮤니케이션은 중요한 역량 중 하나입니다. 이러한 소통 중 하나는 작업 결과물을 설명하는 문서로 이뤄지게 되는데, 개발자가 만들어둔 API를 사용하는 방법을 “설명”하는 “API 가이드”가 하나의 예시라 할 수 있습니다. 글에 기반한 개발자의 커뮤니케이션에는 API 가이드 외에도 SDK나 제품 설명서, 기술 지침서, 설치 안내서 그리고 조직 구성원을 위한 위키 문서 등 다양한 종류가 있지만 이들을 모두 “기술 문서""로 표현하겠습니다.https://oneoneone.kr/content/f8a4cf4d03. 면접관 관점에서 본 좋은 개발자 블로그✅ 개발자 블로그는 취업스펙이 되어버린 듯하다. 도움이 되면서 이력서 첨부해도 도움이 되는 블로그를 쓰는 방법을 전달하고자 한다.https://oneoneone.kr/content/8e653c0104. 컬리, 카카오 등 테크리더 9인 추천 도서 30권✅ 마켓컬리 • 레몬트리 • 카카오 • 코드스쿼드 • 무신사 • 몰로코 • 데이블 • 인프런 • 패스트캠퍼스의 테크 리더 9명이 생애 가장 도움이 된 30가지 도서를 소개합니다.https://oneoneone.kr/content/474a408b05. [리팩토링] 코드 배치와 변수 줄이기✅ 비즈니스 로직을 작성하다보면 코드의 가독성과 길이가 떨어질 수 있다. 코드의 가독성을 높이기 위해 연관된 코드를 근처에 두고, 변수를 줄이는 방식을 사용할 수 있다.https://oneoneone.kr/content/05fbe01006. 웹 개발자를 위한 10가지 유용한 Chrome 확장 프로그램✅ 이 기사에서는 웹 개발자로서 생산성을 향상하고 우리의 삶을 더 나은 방향으로 변화시킬 수 있는 10가지 유용한 Chrome 확장 프로그램을 소개합니다.https://oneoneone.kr/content/76f36e7007. 제4회 Kakao Tech Meet에 초대합니다!✅ 카카오의 공개 기술 세미나인 Kakao Tech Meet #4는 JDK 21의 버추얼 스레드와 카카오의 메시지 광고 추천 플랫폼과 MLOps에 대해 이야기하며, 패널토의와 After Meet 프로그램도 진행됩니다. 일시는 12월 12일(화) 19:00 - 21:00이며, 장소는 판교역에 연결된 카카오 아지트입니다.https://oneoneone.kr/content/55e3bbcf08. (번역) HTMX 살펴보기 및 React와 비교하기✅ HTMX는 리액트와 같은 프레임워크의 과도한 복잡성 없이 서버와 클라이언트 사이의 간극을 메우면서 동적인 웹 애플리케이션을 만들 수 있는 새로운 도구로 주목받고 있습니다. HTMX는 자바스크립트 사용이 적고 간단한 HTML 확장을 통해 다양한 기능을 제공합니다.https://oneoneone.kr/content/2a0807c009. 테스트코드 작성 하시나요?✅ 얼마 전 모임에서 만난 후배 개발자가 면접 경험을 공유했다. '면접관이 테스트 코드 작성 여부를 물었다'라고 했다. 나 역시 면접에서 이를 중요하게 여긴다. 왜  그렇게 생각하는지를 좀 정리를 해보려고 한다.https://oneoneone.kr/content/355ad6db10. 개발자로서 나의 성장을 도와준 블로그 쓰기✅ 개발자 이력서에 github와 함께 blog가 필수로 첨부해야 될 존재로서 스펙으로써 작용하게 된 것은 개발자 전체에 좋은 문화가 일반화되었다고 볼 수도 있겠지만 그만큼 부담스러운 요소로써 느껴지는 분들도 많은 것 같다. 그래서 그런 분들을 위해 부담스럽지 않게 자신에게도 도움이 되면서 이력서 첨부해도 도움이 되는 블로그를 쓰는 방법을 전달하고자 한다.https://oneoneone.kr/content/37cfe63a🙋 일일일 인재풀 서비스 소개인재풀에 등록하면 내게 맞는 기업을 찾아 서류 전형 없는 면접 기회를 제공해 드립니다.
>> 인재풀 등록하기 (PC에서만 가능)
>> (채용 담당자라면) 추천 인재 받아보기🎁 인재풀 등록 시 커리어 치트시트 무료 제공!커리어 치트시트는 이직을 준비하는 인재 분들을 돕기 위해 제작되었습니다.다른 곳에서는 쉽게 찾기 힘든 양질의 정보들이 지속적으로 업데이트될 예정입니다.인재풀 등록 완료 시 1일 이내에 권한을 추가해 드립니다.[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 2주차",https://velog.io/@oneoneone/TOP-10-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EB%A7%8E%EC%9D%B4-%EC%9D%BD%EC%9D%80-%EC%95%84%ED%8B%B0%ED%81%B4-%EB%AA%A8%EC%9D%8C-11%EC%9B%94-3%EC%A3%BC%EC%B0%A8
"영재 소년, 택배 상하차를 뛰다.",Kyle.log,https://velog.velcdn.com/images/kyleryu/post/74a51e7b-f7f1-47a1-8662-d46c8efbff42/image.png,"영재 소년, 택배 상하차를 뛰다.스타트업""못 배워서 이런 일이나 하지.""라는 말도 들었습니다.
그들에게 상처받지 마세요.저는 완벽한 사람이 아닙니다. 패기 넘치는 젊음도 아닙니다. 오히려 계속 깨지면서 실패가 당연해졌습니다.세상은 결과로 말하는 곳임을 잘 알고 있습니다. 이 글을 기반으로 더 빨리 실패하고, 더 빠르게 성장하겠습니다. 훗날 결과로 말할 수 있도록, 도망치지 않도록 기록을 남깁니다.[ 1 ] 세 번의 실패길게도 써보고, 사진도 많이 넣어봤습니다. 아무도 안 읽을 것 같아서 다 지우고 핵심만 담았습니다.1) 음성 기반 커리어 플랫폼, 프로리슨모든 자원이 부족한 스타트업은 뾰족해야 합니다. 무엇을 필요로 하는지 시장조사를 할 게 아닙니다. 무엇이 가장 불편한지 찾아야 합니다. 반대로 실행해서 망했습니다. 해당 분야 프로의 불편함을 경청하겠다는 의미가 지금의 '프로리슨'입니다.2) 웹소설 작가 서포팅 플랫폼, 노벨서포터이번에는 무엇이 가장 불편한지 찾았습니다. 해결책도 꾸준히 테스트하며 검증했습니다. 하지만 이곳에서 제가 생각한 혁신을 이루려면 많은 자금이 필요했습니다. 겨울이 왔습니다. 투자 기반이 아닌 자생력 있는 아이템이 필요했습니다.글을 줄였지만 모든 아이템에 전심으로, 밤낮없이 매달렸습니다. 커뮤니티와 자료 분석 후 작가님들, 업계 관계자분들을 만났고 관련 서적도 읽었습니다. 개발보다는 조사와 분석, 발로 뛴 시간이 더 많았던 것 같습니다.
3) 과외 중개 플랫폼, 프로과외25~80%에 달하는 수수료를 10%로 낮추고 업계 시스템을 개선하는 게 1차 목표였습니다. 누적된 불만과 요구사항도 명확했고요. 플랫폼 특성상 확실한 Lock-In 효과가 없으면 가격경쟁이죠. 혼자라서 버틸 자신이 있었습니다. 구현하고 유지 보수할 핵심 기능도 많지 않았습니다. 출시를 앞두고 과외 앱 살인사건이 발생했습니다.출처: 서강학보
이제 '핵심 교훈'과 '앞으로의 계획'을 풀어보겠습니다.핵심 교훈
[ 2 ] 사업계획서 X, 빠른 테스트 O
[ 3 ] 기술의 함정앞으로의 계획
[ 4 ] 왜 다시 어려운 길을 갑니까?[ 2 ] 사업계획서 X, 빠른 테스트 O스타트업은 최고의 경력자가 모여도 실패합니다. 성공적 엑싯을 경험한 연쇄 창업가의 다음 제품이 별다른 호응을 얻지 못하고 사라지는 사례도 보셨을 겁니다. 그래서 더 작고, 더 빠르게 시도해야 합니다.출처: 구글 최고의 혁신 전문가, 알베르토 사보이아 
""대부분의 신제품은 시장에서 실패한다. 유능하게 실행해도 마찬가지다.""맥킨지 출신 대표의 사업계획서도 실패합니다. 완벽한 조사와 전략, 수많은 분석 기법들? 다음 라운드에 필요한 것 같습니다. 일단 '될 놈'을 찾아야죠. 그러려면 정말 가벼워야 합니다.멋들어진 사업계획서 쓸 시간에 아주 가벼운 테스트 제품을 만들어야 합니다. 투자를 위한 MVP를 말하는 게 아닙니다. 그것보다 훨씬 가벼워야 합니다. 각종 지원 사업과 완성도에 대한 집착이 독이 됐습니다.초기 대표님들 연락이 많이 왔습니다.  이 글보다 짧게, 실패한 키워드와 앞으로 풀 주제를 꺼냈습니다. 갑자기 조언을 주십니다. ""어려운 주제만 하시는 거 같은데... 사업계획서 써보셨어요?"", ""어린데 취직이나 해요~ 직장 경험이 없으니까 세 번이나 실패하는 거야.""
3~5년 차 경력, 이제 사업을 시작하신 분들입니다. ""네, 말씀 다 맞습니다.""라고 넘기는 편입니다. 제가 어떤 자세와 밀도로 살아왔는지 모르시니까요. 굳이 꺼낼 필요도 없고요. 오히려 대선배님께서 존중과 격려, 깊은 통찰력을 보여주십니다.
[ 3 ] 기술의 함정세 번째 아이템 '과외 중개 플랫폼', 업계 1위의 웹 기술 스택입니다. 세상에는 jQuery와 PHP 만으로 성공한 회사도 정말 많습니다. 개발을 하다 보면 기술에 매몰되기 쉽죠. 그러나 0에서 1을 만들 때 생각보다 대단한 기술이 필요하지 않습니다. 항상 이 기술과 코드가 만드는 사업적 가치에 집중해야 합니다.가난한 초기 스타트업인데 완벽한 설계? 기술 부도보다 자금 고갈이 빠릅니다. 토스, 배달의민족 같은 100을 따라 하다간 굶어 죽습니다. 일단 0에서 1을 만들어야 살아남습니다. 그들도 처음부터 100은 아니었습니다.물론 적절한 부채 상환은 중요합니다. 사업적 관점에 치우친 경영자는 기술 부채의 위험성을 간과합니다. 결국 유능한 개발자는 떠나고 고인물만 남습니다. 기업 리뷰를 보니 리액트 리뉴얼을 시도하는데 과도하게 쌓인 기술 부채가 발목을 잡고 있었어요. 기술, 사업 어느 한 쪽으로 쏠리면 안 됩니다. 둘 다 챙겨야 합니다.[ 4 ] 왜 다시 어려운 길을 갑니까?과외 앱 살인사건 이후 '치안 공백', '안전'이라는 키워드로 이동했습니다. 범위가 너무 넓죠? 핵심 고객, 누가 가장 불편한지 찾아야 합니다.'여성'이었습니다. 그중에서도 '1인 가구'입니다. 호신용 스프레이? CCTV? 다 좋습니다. 그런데 왜 계속 막연한 두려움이 남을까요? 혼자라는 불안감이 그대로입니다.여성 1인 가구 수는 꾸준히 증가하고 있습니다.
출처: The JoongAng
이 '혼자라는 불안감'을 해결할 계획입니다. 저는 완벽한 사람이 아니고, 혼자 가면 느립니다. 제가 세우는 가설이 틀릴 수도 있습니다. 그래서 함께 가려고요.지금까지 왜 혼자 했냐고요? 어딜 가든 리더였고, 사람 좋아합니다. 그런데 사람을 이끈다는 것에 얼마나 큰 책임감이 필요한지도 잘 압니다. 확실한 궤도에 오르거나, 정말 함께 풀고 싶은 문제가 아니면 혼자 간다는 생각이었습니다.누군가 그러더군요. ""실패를 반복하다 보면 10년을 걸 수 있는 진짜 문제를 만나게 된다.""라고요. 엄청난 문제를 찾았을 때 창업하는 게 아니라, 뭐라도 해보면서 실패하는 게 낫다고 판단했습니다. 그 결과가 세 번의 실패, 다음 문제, 지금 이 글입니다.이 문제가 10년을 걸만한 일이냐고요? 모릅니다. 온갖 시련에 부딪히고 깨져봐야 압니다. 그래도 함께 풀고 싶은 주제는 맞습니다. 실패해서 사라질 수도 있습니다. 많이 아프겠죠. 하지만 최선을 다했음에도 실패한다면, 그 실패는 다음에 올 위대한 이들의 자양분이 될 겁니다. 그러면 더 나은 세상에 기여한 거 아닙니까?출처: https://youtu.be/B9LIYb3BIQ8?si=MetLxJBdAnXe8b6c
업계 선배님께서 제 짧은 인생 굴곡을 들으신 뒤 이런 질문을 주셨습니다. ""대표님, 기껏 과외 같은 쉬운 길 찾고서 왜 다시 어려운 길을 갑니까?""제가 뭐라고 말씀드렸을까요? 자세히는 말씀 못 드리지만 주제는 '머리가 아니라 가슴이 시켜서'입니다. 제가 배가 불러서, 덜 깨져서 그럴까요? 아뇨, 정말 서럽게 울어봤습니다. 그래서 한 번 사는 인생, 가슴이 시키는 일을 하고 싶었습니다.실패할 수도 있습니다. 아니, 실패할 겁니다. 운이 좋으면 성공할 겁니다. 그래도 끝까지 함께 풀어보고 싶다면, '안전'이라는 영역을 혁신하고 싶다면 언제든 연락 주세요.kyle@prolisten.net맺음말이전 글 때문에 제가 금수저라 생각하셨나요? 학벌도 대단하겠지? 부모님은 대기업 사내 부부셨고, 이후 벤처기업을 운영하시는 아버지를 보며 CEO라는 꿈을 키웠습니다. 큰 부족함 없이 자랐고, 유학을 꿈꿨던 시절도 있습니다. 그런데 삶이란 게 항상 뜻대로 풀리지는 않더라고요.택배 상하차를 뛰었고, 식당 홀서빙을 했습니다. ""못 배워서 이런 일이나 하지.""라는 말도 들었습니다. 태풍이 오는 날 우유배달을 하면서 울었던 기억도 납니다. 그렇게 퇴근한 뒤 책을 읽고, 강의를 들으며 공부했습니다.목표에 도달할 수 있다면 자존심 따위는 쉽게 내려놓습니다. 하지만 제 삶의 무게와 가치는 결코 가볍지 않습니다. 나의 겉모습이나 한 면만 보고, 모든 걸 아는 듯 훈수 두는 사람을 멀리하세요. 많이 모자라고, 깊이도 얕은 사람입니다.본인이 제일 잘났다고, 남을 가르치려 드는 오만한 자는 '성장할 수 없는 사람'입니다. 그들에게 상처받지 마세요. 무례함과 솔직함은 다른 말입니다. 상호 존중이 결여된 조직과 사람은 반드시 무너집니다.부족한 글 읽어주셔서 감사합니다. 다양한 고민 속에서 오늘도 치열하게 살아가는 모든 분들을 응원합니다. 이 글이 조금이라도 도움이 됐기를, 작게나마 힘과 위로가 되었기를 바랍니다.10살 꼬마 개발자, 판교 스타트업 대표가 되다.잘 읽고 갑니다!!.. 사업계획서 X, 빠른 테스트 O 색션에서 저도 매번 뼈저리게 느끼는 것 같네요!! 화이팅!!고통없인~성공이란 없습니다. 대신~힘든 고통이 오래지속되면 삶에 실패입니다^^
어제보다 나은 오늘!~오늘보다 나은 내일를 위해~ㄱㄱㄱ~
좋은글 잘 읽었습니다~~화이팅~@@@글 잘 읽었습니다.  좀 다른 질문인데 혹시 서강대생이신가요?멋지다 멋져 항상 동기부여 주셔서 감사합니다 ㅎㅎ 짱짱막연하게 불안을 느낌 아침에 귀한 글 읽고 힘을 얻어 갑니다. 응원합니다!! ",https://velog.io/@kyleryu/%EC%98%81%EC%9E%AC-%EC%86%8C%EB%85%84-%ED%83%9D%EB%B0%B0-%EC%83%81%ED%95%98%EC%B0%A8%EB%A5%BC-%EB%9B%B0%EB%8B%A4
[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 2주차,oneoneone.log,https://velog.velcdn.com/images/oneoneone/post/a7fb73ae-9506-43be-8fff-168f683b74c0/image.png,"[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 2주차동료들은 다 아는 정보, 나만 모르지 않게 만들어주는
일일일에서 한 주간 개발자들이 많이 읽은 상위 10개의 아티클들을 소개합니다.📌 실시간으로 나와 비슷한 동료들이 많이 읽은 아티클을 보고 싶다면?
>> '일일일 - 개발' 오픈채팅방 (참여 코드 : oneone1)01. (해외) JSON이 느립니다. 여기 4가지 더 빠른 대안이 있습니다✅ JSON의 세계에 대해 자세히 알아보고, 잠재적인 병목 현상을 살펴보고, 앱이 더 빨라질 수 있도록 대안과 최적화 기술을 알아보세요.https://oneoneone.kr/content/273a29a402. null 리턴은 왜 나쁠까?✅ null 리턴은 코드의 복잡성을 높여서 사용자 고객에게는 버그와 장애를, 개발자 고객에게는 낮은 생산성을 가져올 수 있다. 코드를 읽는 사람 입장에서 null이 왜 복잡성을 만드는 '나쁜 코드'인지 알아볼 수 있다. 이를 위해 코드에 맥락을 명시적으로 드러내고, 필요한 기능을 필요할 때만 제공하는 방식으로 개발자 고객을 위한 코드 복잡성 관리를 해야 한다.https://oneoneone.kr/content/f0becf1703. Discord가 한대의 서버로 2백만명의 동시 사용자를 서빙하는 방법✅ ETS에 저장하여 빠른 액세스와 작업 처리 시간을 확보함. 프로세스가 작업을 수행할 때마다 ETS에서 멤버 목록을 조회하여 필요한 정보를 얻음. 이를 통해 서버의 반응성을 높이고 작업 시간을 단축하여 사용자 경험을 향상시킴.https://oneoneone.kr/content/beb09d5704. TDD, 실패하는 테스트부터 작성해 얻는 것 5가지✅ ‘테스트 주도 개발(Test-Driven Development, 이하 TDD)’은 켄트 벡이 만든 개발 방법으로, 작동하는 깔끔한 코드를 만들기 위해 빨강/초록/리팩토링 사이클을 반복하는 것이 특징이다. TDD의 궁극적인 목표는 테스트가 아닌 작동하는 깔끔한 코드이고, 변경이 쉬운 코드를 만들기 위해 작업을 구조화하는 기술이다. 미들웨어를 예시로 들어 TDD를 통해 변경 용이한 코드를 만들 수 있다는 것을 설명한다.https://oneoneone.kr/content/d4c77a1305. Production 환경에 기능을 안전하게 배포하고 실험하기,✅ Production 환경에서 켜거나 끌 수 있는 토글 스위치입니다. 이를 통해 정교한 제어와 기능 롤아웃 전략을 구현할 수 있습니다.https://oneoneone.kr/content/13fc9d7e06. [번역] 웹 컴포넌트는 자바스크립트 프레임워크보다 오래 살아남을 것 입니다✅ HTML, CSS, JavaScript로 작성된 프로젝트에서 웹 컴포넌트를 사용하여 모든 코드를 한 곳에 모아두고 마크다운 파일을 사용하여 콘텐츠를 쉽게 이동할 수 있는 장점을 설명하며, 웹 컴포넌트의 유지 보수에 대한 걱정을 나타냄.https://oneoneone.kr/content/cd4458c607. “최신 정보 반영하고 더 많은 텍스트 입력”…‘GPT-4 터보’ 발표✅ 오픈AI가 GPT-4 터보를 발표했다. 이는 최신 정보를 반영하고 멀티모달 기능을 강화하여 기존 버전보다 더 많은 텍스트를 입력할 수 있으며, 이용료도 낮췄다. 또한 사용자는 GPTs를 사용하여 맞춤형 챗봇을 만들고 판매할 수 있다.https://oneoneone.kr/content/d829d06008. 자료구조 개념 이해하기 ‘힙과 힙 정렬 알고리즘’✅ 자료구조는 데이터를 효율적으로 저장, 검색, 삭제할 수 있도록 설계된 구조나 방법을 의미하며, 힙은 정렬, 우선순위 큐, 스케줄링과 같은 알고리즘에서 활용되는 자료구조이다. 힙은 완전 이진 트리의 일종으로, 부모와 자식 노드 간에 특정한 조건을 만족하는 자료구조이다.https://oneoneone.kr/content/3ad818fc09. (해외) Universe 2023: Copilot은 GitHub를 AI 기반 개발자 플랫폼으로 전환합니다.✅ GitHub는 Copilot X를 통해 AI가 개발자 라이프사이클의 모든 단계와 함께 작동하는 소프트웨어 개발의 새로운 미래 비전을 공유했다. 그 결과로 GitHub Copilot은 GitHub를 세계 최고의 AI 기반 개발자 플랫폼으로 발전시켰으며, Copilot Chat을 통해 단어로 코드를 작성하고 이해할 수 있다. GitHub Copilot Enterprise는 조직의 개인화 된 Copilot을 제공하고, GitHub Copilot Partner Program을 통해 제삼자 개발자 도구 및 서비스와 통합한다.https://oneoneone.kr/content/22202a1410. 파이어베이스 킬러? 요즘 대세는 수파베이스!✅ 오늘은 오픈 소스 Firebase 대체품인 슈퍼베이스에 대해 개요를 설명하고 싶습니다. 마치 Firebase처럼 슈퍼베이스는 백엔드 서비스 플랫폼으로, 서버, 업데이트, 보안 등을 직접 구축할 필요 없이 필요한 모든 기능을 제공합니다. 슈퍼베이스와 Firebase는 인증, 데이터베이스, 파일 저장, 실시간 및 서버 리스 기능을 몇 번의 클릭과 몇 줄의 코드로 프로젝트에 추가할 수 있습니다. 그러나 두 플랫폼의 동작 방식은 매우 다르기 때문에 슈퍼베이스의 개발 방식은 무시하기 힘듭니다.https://oneoneone.kr/content/cf97852d🙋 일일일 인재풀 서비스 소개인재풀에 등록하면 내게 맞는 기업을 찾아 서류 전형 없는 면접 기회를 제공해 드립니다.
>> 인재풀 등록하기 (PC에서만 가능)
>> (채용 담당자라면) 추천 인재 받아보기🎁 인재풀 등록 시 커리어 치트시트 무료 제공!커리어 치트시트는 이직을 준비하는 인재 분들을 돕기 위해 제작되었습니다.다른 곳에서는 쉽게 찾기 힘든 양질의 정보들이 지속적으로 업데이트될 예정입니다.인재풀 등록 완료 시 1일 이내에 권한을 추가해 드립니다.[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 1주차[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 11월 3주차",https://velog.io/@oneoneone/TOP-10-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EB%A7%8E%EC%9D%B4-%EC%9D%BD%EC%9D%80-%EC%95%84%ED%8B%B0%ED%81%B4-%EB%AA%A8%EC%9D%8C-11%EC%9B%94-2%EC%A3%BC%EC%B0%A8
왜 모승은 스타트업에서 개발자를 하고있나요?,endmoseung.log,https://velog.velcdn.com/images/endmoseung/post/8ea5f3d5-f335-47d1-8620-2335c5091bf3/image.png,"왜 모승은 스타트업에서 개발자를 하고있나요?최근에 인싸담당자라는 유튜브 채널에서 스타트업에 관련해서 얘기를 나누는 자리를 가졌습니다.
정말 많이 준비하고 갔는데 카메라 앞이라서 너무 긴장해버린탓에 반도 얘기를 못 했던게 너무 아쉬워 글로 남기려고 합니다.
다시 한번 저에게 이런자리를 마련해주신 AND studio X 아산나눔재단 관계자분들께 너무 감사드립니다.1. 스타트업 왜 왔어?저는 개발자 모승입니다.안녕하세요, 저는 호두랩스라는 스타트업에서 1년정도 재직중인 개발자가 천직인 프론트엔드 개발자 김승모입니다.
저희 회사는 “교육격차뿌셔”라는 슬로건을 갖고 많은 아이들에게 교육격차를 해소하기 위해서 문제를 해결하고 있는 에듀테크 회사에요.
현재 시리즈 B투자를 받은 회사이고 ,군자에서 40명정도 재직중인회사에요.
프론트엔드 개발자로서 하는 일저희 회사는 게임, 앱, 웹으로 사용자들에게 서비스를 제공하고 있는데 저는 그중에서 웹으로 제공하는 서비스 대부분의 유지보수와 새로운 서비스 개발을 하고 있어요.
요즘은 저희 회사가 가지고 있는 교육 솔루션을 베트남, 일본, 국내 학원들에게 제공하기 위한 플랫폼을 개발중이고, 또한 호두클래스라는 화상교육 서비스를 진행하고 있는데 이에 대한 유지보수와 신 기능들을 개발하고 있어요.
그리고 저는 팀 문화에도 관심이 많아서 애자일 스프린트를 여러번 경험해봤고 사이드 프로젝트에서 직접 스프린트를 리드해본적도 있어요.
그떄의 경험을 살려서 현재 저희팀이 매일 진행하는 아침 데일리스크럼 진행을 하고 있고 그 외에 다른팀과의 소통도 하고 있습니다.현재 회사로 오게 된 이유저는 탄탄대로 개발자가 된 케이스는 아니에요. 저는 지방에 살고 비전공자에 독학으로 개발을 시작했고 그 과정에서 개발자 커뮤니티에서 많은 도움을 받았어요. 그 과정에서 온라인으로 강의도 듣고 스터디도 진행하면서 오픈카톡이나 SNS에서 궁금한것을 물어봤어요.
그렇게 예전에는 없었지만 디지털화 되면서 너무 좋아진 교육을 받을 수 있었어요. 자연스럽게 저도 나같은 개발 지망생들을 위해 도와줄 수 있는 교육쪽에 관심이 많았어요.
그러다보니 저는 제가 좋아하는 교육과 게임쪽 서비스를 할 수 있는 회사를 찾았고, 호두랩스에 지원하여 두번의 면접을 통해 입사하게 됐어요.아래에서 조금 더 자세하게 제가 회사에 취업하기까지에 대한 이야기를 보실 수 있어요.
비전공 독학 백수에서 취업하기성장과 왜?를 중요하게 생각하는 사람저는 성장과 왜?를 중요하게 생각했어요. 어떤일을 하더라도 이것이 왜이런걸 하게 됐고 그걸 쓰는 사용자는 누구인지 정말 관심이 많아요. 대기업에서도 잘 성장할수 있지만 스타트업에서 다양하게 배우고 많은 경험을 해볼 수 있었고, 최대한 다양한 직군과의 소통을 잘 할 수 있어야했는데 스타트업이 아무래도 그런부분에 많은 도움이 될 것 같았어요.
여러분들도 같이 공부할떄 뭔가 더 잘되는 경험을 해보신적 있지 않으신가요? 저도 취준할때 같이 공부하면서 같이 성장하는 즐거움을 알게 됐어요. 그래서 이런 즐거움을 회사에서도 느끼고 싶었고 회사와 저가 같이 성장하는 그런 기분을 꼭 느껴보고 싶어서 스타트업을 선택했습니다.2. 다녀보니 어때?수평적인 회사솔직히 처음다녔을땐 너무 놀랐어요. 제가 울산에 살다보니 대기업 생산직에 다니던 친구들에게 들은 회사분위기랑 너무 달랐어요.
우선 다들 에어팟끼고 편안한 옷을 입은것부터 MZ스러웠고 대표님도 직원들에게 관심이 많으셨어요. 그외에 충분한 근거가 있다면 제가 해볼수 있는게 많았고, 저에게 대표님과 부대표님을 자주 만나서 얘기 해볼 수 있는 경험은 너무나 값진것 같아요.해볼 수 있는건 시도할 수 있는 분위기충분한 근거가 있다면 제가 할 수 있는걸 많이 경험해볼 수 있다고 생각해요. 가령 회사에서 최근에 진행하고있는 테크톡 발표라던가 현재 제가 아침 데일리스크럼을 맡아서 진행하고 있던것 또 코드리뷰하는것은 제가 근거를 들어 제시하여 반영된것이거든요.
그리고 저희회사는 기술스택에 있어 자유로운편인데 이런부분 또한 너무 좋았어요. 개발자들은 늘 기술에 목말라있거든요.
저는 경험을 많이할수록 성장도 많이 할수도 있다고 생각하는데 저희회사에서 많은 경험을 할 수 있고 피드백을 줄 수 있는 좋은 동료도 있어서 많이 성장한것 같아요.일이 많긴 하지만...스타트업을 정의하면 제한된 자원으로 혁신적인 아이디어를 구현하려는 도전적인 상황을 해결하는 회사라고해요. 그렇기에 일이 없는편은 절대 아니에요. 흔히 달리는 자동차에 바퀴를 바꾼다고 표현하잖아요?
그래서 입사 처음에는 제가 많이 부족하기도 하고 일들이 겹쳐서 야근할떄도 많았어요.
그떄는 정말 힘들었는데 돌아보니까 다 제 경험이더라구요. 그리고 어느정도 일이 편해지니 덜 일할수도 있었구요.
그래서 일이 조금 많긴 하지만 제가 좋아하는 일이기도 하고 다양한 경험을 해보면서 좋은 성장이 된것 같아요.내가 회사에서 성장하는법커리어를 키우기 위해서 저는 회사에서 많은 문제를 해결하려고 해요. 커리어를 한글로 풀어쓰면 경력이잖아요? 스타트업이다보니 문제가 많을 수 밖에 없어요. 그래서 저는 그런 문제들을 발견하고 어떻게 하면 해결할수있을까 고민하고 이것저것 도입해볼 수 있는 다양한 레퍼런스들을 찾아보고 만약 적용해볼만 하다면 개인적으로 하나 만들어보면서 해당 기술을 도입해봐요.
여기서 쓸만하다면 실제로 회사 프로덕트에도 적용해요. 하지만 이렇기에 야근을 할떄도 있었어요.
하지만 자연스럽게 그게 다 제 경험이 되더라구요.
회사밖에서는 개인적으로 부족하거나 회사에서 적용할 수 있는것에 대해서 공부해요.그리고 요즘에는 프론트엔드 개발뿐만 아니라 인프라도 조금씩 공부하고 있구요.
저는 혼자 공부하는것보단 같이 공부를 하는게 잘 됐기에 강남역에서 직접 스터디를 열어서 다른 개발자들과 공부하고 있어요. 또한 블로그를 쓰면서 제 경험이나 알고있는것을 사람들에게 공유한다거나 컨퍼런스같은 행사에서 스피커혹은 스태프로 참여하면서 최대한 많은 경험을 하고 있어요.아래 글에서 회사에서 테크톡을 준비했던것에 대해서 알아보실 수 있어요.
테크톡으로 성장하기회사에서 얻을 수 있었던 것회사에 재직하면서 개발적으로나 인격적으로도 많이 성장했어요.
제가 회사에 들어오기전에 이것저것 해보긴 했지만 서비스가 유저들에게 제공되고 해당 서비스를 유지하는 경험을 깊게 해보진 못했어요.
하지만 회사에서는 다양한 경험을 할 수 있었고 개발을 잘 할 수있는 최고의 동료가 같이 있으니 시야도 많이 넓어졌고 개발 스킬과 다양한 방법을 배울 수 있었어요.
예를 들면 지구 반대편에 있는 유저가 우리나라의 시차와 차이가 많이나서 버그가 난 적도 있었구요. 이런 경험을 회사가 아니라면 절대 못해봤을것 같아요.
두번쨰는 제가 이 회사가 첫회사였는데요.
지금도 완벽한 인격은 아니나 회사 이전에는 더욱더 그러지 못한편이었던것 같아요. 하지만 회사에서 좋은 사람들이 소통하는 방법을 배웠고 이런 소프트스킬을 잘 흡수해서 인격적으로도 많이 성장한것 같아요.3. 다녀보면 어떨까?스타트업에 잘 맞는 성격인것 같아?네 저는 잘 맞는것 같아요. 제 MBTI가 ENFP인데요. 이 유형의 사람들은 하고싶은것도 많고 좋아하는걸 정말 재밌게 한다고해요. 그래서 저는 지식을 공유한다거나 이것저것 시도하고 있어요. 그런데 스타트업에는 새로운 시도나 동료들에게 정보를 공유해야될 일이 정말 많잖아요? 그래서 저는 이런걸 잘 할수있는 스타트업이 제 성격에 맞는것같아요.큰 회사도 가보고 싶어?프론트엔드 개발에서 그런것들이 많은데 무조건 맞는 정답은 없는것 같아요. 예를들면 상위호환인 기술이 아닌이상 기술의 각자 장단점이 있고 그걸 잘 활용하는 개발자가 잘하는 개발자라고 생각해요. 제가 왜 이말을 했냐면 스타트업과 큰 회사도 각자 다른경험을 할 수 있잖아요? 아무래도 스타트업은 사람이 적고 증명해야할 일이 많기에 여러 경험을 해볼 수 있고 팀을 직접 빌딩하고 리딩하며 없던걸 만들어내는쪽에 가깝다고 생각해요. 하지만 대기업은 사람이 많고 증명해야할일이 상대적으로 적은 대규모 서비스이기에 어떤 문제를 깊게 해결해볼 수 있는 경험을 할 수 있다고 생각해요.
그래서 저는 지금 우리팀에서 해볼 수 있는 경험들을 충분히 한다면 다른 경험도 해보고 싶어요. 다양한 경험을 한다면 인격적으로나 실력적으로도 많이 성장할 수 있을것 같아요.요즘 하고 싶은것들우선 회사 기술 블로그를 제가 직접 개발해보고 싶어요.
우리팀이 계속 성장하여 다양한 문제들을 해결하여 이걸 기술블로그에 업로드하여 다른 회사들이 호두랩스라는 회사라면 정말 개발자가 갈만한 회사라는 인식이 심어질 수 있도록 노력해보고 싶어요.
또 가능하다면 회사 프론트엔드 개발자 채용 과제도 만들어보고 싶어요.
그리고 제가 남에게 알려주는것을 잘한다고 대학생떄 들은적이 있는데 그래서 저는 개발자들을 위한 강의도 런칭해보고 싶어요.
마지막으로 아직 못한 올해 목표가 있는데 나만의 블로그, 포트폴리오 사이트 만들기를 완성하고 싶어요.어떤 개발자가 되고 싶을까좋은 개발자가 되고 싶어요. 개발자라는 직업이 개발을 잘해야하는것도 있지만 협업도 잘해야 하잖아요? 저는 개발에도 관심이 많지만 좋은 팀이 되기위한 관심또한 많아서 10년뒤에는 그런걸 잘 할수있는 리더가 되고 싶어요.
스타트업 지원을 망설이는 취준생에게 한 마디?스타트업 희망편을 설명드렸는데 스타트업 지원을 망설이는 분들이 어떤 고민을 하고 있는지 알고 있어요. 저 또한 그런 고민을 많이 했어요. 할 수 있는게 많은 만큼 회사에 사수가 없다거나 레거시가 많다거나 체계가 제대로 잡혀있지 않는 경우도 있잖아요?
근데 다르게 생각하면 그만큼 내가 하고 증명할 수 있는 기회또한 많다라고 생각해요. 최근에 갔던 컨퍼런스에서도 연사분이 망해가던 팀원을 리드하면서 이것저것 해본 경험으로 개발 문화를 구축하면서 많이 성장했다 라고하셨는데 너무 공감됐어요.
반대로 너무 잘돼있는 회사에가면 잘 성장할순 있겠지만 이미 잘되있기에 내가 할 수 있는게 많지 않다라고 들었거든요.
그리고 살다보면 가슴이 뛸 만큼 열정적인걸 만나서 그것에 인생을 태워보고 싶다는 생각할때가 있잖아요? 스타트업에서 그런 경험을 해볼수 있다면 그 경험은 죽을떄까지 간직할 수 있는 소중한 경험이 될거라고 생각해요.
제가 좋아하는 개발자분이 항상 상놈식으로 공부했다고해요. 물론 대기업에가서 양반처럼 공부하는것도 성장이 많이 되겠지만 스타트업에 가서 상놈식으로 경험해보는것도 충분히 도움이 될거라고 생각해요.4. 끝으로근황벌써 입사한지 1년이 되어가네요. 이런저런 방황을 하면서 비록 제 인생의 시작은 좋지 않았으나 운좋게 개발자라는 직업을 알게돼서 요즘 회사에서나 외적으로나 많이 바쁘지만 하루하루 재밌게 살고있는것 같습니다.
한참 취준할때 네이버 황준일님 회고글을 보면서 어떻게 저렇게 열심히 살 수 있을까 많이 대단하게 생각했는데 일단 하나하나씩 하다보니까 저도 지금까지 많은걸 할 수 있었던것 같아요.
근황을 얘기하자면 7개월만에 회사에도 많이 적응하고 최근엔 테오콘 2회차를 마무리 지었으며 현재 진행중인 프론트엔드 스터디도 벌써 4번쨰 책을 진행중입니다.

이번처럼 제 얘기를 직접 전달하기 위해 스피커로도 활동하고 있고 지금처럼 촬영도 하고 있어요.많은것을 하고 있는만큼 제 하루 루틴은 회사 -> 저녁 -> 카페 -> 헬스 -> 잠 반복이고 주말에도 스터디준비와 모각코를 하고있어서 마냥 쉬지만은 못
하는거 같아요.아직도 프론트엔드 개발자로서 부족한것도 많고 그외에 알아야하고 배워보고 싶은것도 많아서 공부또한 놓지않고 있습니다. 최근에는 인프라에 대해서 공부해보고자 저희 회사 데브옵스 개발자님의 추천에 따라서 docker도 공부해보고 있고 NextJs 13에 대해서 공부를 많이 했어요.(근데 벌써 14버젼이 나왔네요.. ㅋㅋㅋ)저는 위에서 말했던것처럼 상놈식으로 공부하는 사람이에요. 최근에 바닐라로 SPA에 관한 공부와 docker공부중인데 일단 만들어보는게 이해가 제일 잘 되더라구요. 아래는 최근에 사용중인 레포지토리들이에요.
아는 동생이 선물해준 docker 휴지곽이에요.
그럼에도 불구하고 저는 하루하루가 너무 재밌고 그 과정에서 다양한 사람들과 만나면서 성장하는게 너무 즐거운것 같아요.
앞으로도 꾸준히 내가 할 수 있는것을 늘리고 많은 스타 개발자들이 그랬던것처럼 저 또한 그런 사람이 되어 받은만큼 돌려주고 싶습니다.스타트업좋지 못한 환경이나 좋은환경에서나 많은 분들이 스타트업에서 본인의 업무를 이시간에도 쳐내시고 있는것 같아요.
제가 존경하는 개발자분께 이런 고민을 털어놓으면 현재 처한 상황에서 할 수 있는걸 적용해보고 기록화해라라고 하시고 저 또한 그런 상황이 온다면 최대한 많이 해보려고해요.
또한 저처럼 스타트업에서 지내고 있는 사람들을 너무 응원하며 모두 잘 되셨으면 좋겠습니다!정말 끝으로딱 1년차가 됐을때 그동안 못가봤던 해외여행도 혼자 다녀오고 그 이후에 개발자가 된지 1년차에 대한 회고도 한번 작성해봐야겠습니다. 일본 가보고 싶네요.
항상 제가 잘하고 있는지는 모르겠지만 주변에 좋은 개발자 지인분들이 많아지는걸 보거나 할 수 있는 얘기가 많아지는걸 보면 제가 그냥저냥 살고만 있는것 같지는 않네요.제 얘기는 유튜브 인싸담당자에서 보실 수 잇습니다.
혹시나 저와 더 얘기하고 싶거나 물어보고 싶은게 있다면 언제든지 편하게 댓글이나 제 SNS로 연락주시면 감사하겠습니다.레몬이 있으면 레몬에이드를 만들어라.모노레포 과연 필요할까?html css 배워보기잘읽고 갑니다.
도커 휴지곽 탐나네용 ㅎㅎ도커 휴지곽으로 간접 출연하여 기쁘네요🤓 모승의 좋은 개발자를 위한 매일매일을 응원합니다~잘 읽고갑니다 !!",https://velog.io/@endmoseung/%EC%99%9C-%EB%AA%A8%EC%8A%B9%EC%9D%80-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%ED%95%98%EA%B3%A0%EC%9E%88%EB%82%98%EC%9A%94
개발자 부부가 되고 싶어서 여자친구를 개발자로 만든 SSul 푼다.,기록은 기억을 이긴다 🌱,https://velog.velcdn.com/images/joshuara7235/post/75304279-6b00-47b2-8d1c-a2584012c0ea/image.jpeg,"개발자 부부가 되고 싶어서 여자친구를 개발자로 만든 SSul 푼다.개발자 부부 SSul🌱 들어가며올해 6월.약 2년 정도 교제했던 여자친구와 결혼에 골인했다. 💍언젠가는 내 블로그에 결혼과 개발자에 대해 함께 써보고 싶었다.관련하여 참 많은 주제가 생각이 났는데, 그 중 가장 먼저 쓰고 싶은 이야기를 써보려고 한다.나와 와이프의 공통점
1. 철저한 문과 출신이다. 고등학생때도 문과, 대학생 전공도 문과계열.
2. 개발자가 되기 전에 여러가지 직무를 경험했다. 당연히 개발관련은 절대 아니다.
3. 많은 인생의 굴곡을 겪고나서 개발자가 되기로 결심했다.🐥
👨🏻‍💻와이프를 처음 만났을 때 나는 겨우겨우 부트캠프를 끝내고 작은 스타트업에서 개발자로 첫 취업을 시작한 신입 백엔드였다.
👩🏻‍💻와이프는 나와 교제를 하고 1년 정도 후에 개발자가 되기위한 코딩공부를 시작했다.

🤖
👨🏻‍💻현재 나는 3년차 백엔드 개발자로, 스타트업과 중견기업을 거쳐 새로운 도전을 위해 다시 스타트업에서 커리어를 시작했다.
👩🏻‍💻현재 와이프는 막 2년차가 된 프론트엔드 개발자로, 코스닥 상장 보안회사에서 커리어를 이어가고 있다.요새 개발자 부트캠프 광고가 너무 많다.
많아도 너무 많다.어떤 광고는 혹하게 만들지만, 다시 생각해보면 말도 안되는 광고들이 수두룩하다.🙄
마치 3,4 개월만 공부하면 연봉 6000만원은 거뜬하게 받을 수 있는 것처럼 이야기한다. 😵‍💫그런 현실 속에서 와이프가 개발자가 된 과정을 옆에서 지켜보면서 많은 인사이트를 받았다.'개발자가 되기 위해서는 어떤 과정이 있어야 하는가'
'개발자는 어떤 역량이 있어야 하는가'이 글을 통해 전달하고 싶은 내용은 다음과 같다.와이프를 바라보며 '개발자는 어떤 사람이 해야할까' 에 대해 얻은 인사이트생각보다 흔하지 않은 '개발자 부부' 이야기개발자 부부로서 하고싶은 것들🍎 본론 1. 개발자는 어떤 사람이 해야하는 걸까?독하게 살아낸 그녀와이프는 본인이 다니던 직장을 그만두지 않고 퇴근하고 코딩 학원을 주중에 매일 다니며 개발자로의 전직을 준비했다.
현실적인 문제로 돈을 계속 벌어야 했기 때문에 코딩공부를 하기 위해 직장을 그만둘 수 없었다.매일 매일 퇴근하자마자 바로 학원으로 향해서 4시간 강의를 듣고 집에 와서는 새벽까지 과제를 했다.
그리고 다시 아침에 일어나서 직장으로 출근을 했다.
이렇게 약 6개월을 살아냈다.지금와서 생각해보면 와이프가 어떻게 그렇게 살았나 싶다. 🥺와이프는 독하게 살아냈고, 당당하게 프론트엔드로 취업에 성공했다. 그것도 탄탄한 중견기업으로! 🥳옆에서 지켜보는 사람의 입장에서는 사랑하는 사람이 매일매일 지쳐있는 것을 보면 마음이 아팠고, 동시에 존경심도 들었다.
그리고 한 가지 궁금함이 생겼다.무엇이 이 사람을 저렇게까지 포기하지 않고 움직이게 하는 걸까?개발자들을 표현하는 말은 여러가지가 있다.그 중에서 내가 가장 공감하는 세가지 표현이 있다. 개발자는.. 
1. '세상의 문제를 프로그래밍으로 해결하는 사람'
2. '평생 기술적 겸손함을 가지고 공부해야 하는 사람'
3. '무언가를 만드는 것을 꾸준히 하고 즐기는 사람'내가 와이프를 보면서 가진 궁금함과 위의 세가지 표현을 연결시켜서 생각해 보았다.세상의 문제를 프로그래밍으로 해결하는 것사실, 세상의 문제를 해결한다고 하면 거창해보인다.
개발자라는 존재가 세상의 문제를 해결하는 아주 나이스하고 쿨하고 멋진 존재라는 개발자 뽕 🫠 에 빠진 것 아니냐고 말할 수 있다.하지만 세상의 문제를 해결하는 것은 직장인 모두가 직장에서 해내고 있다.
개발자가 개발자로서 세상의 문제를 해결하는 것은 다음과 같다. 개발자가 세상의 문제를 해결하는 방법회사에서 버그 하나를 해결하는 것회의를 통해 기획에 맞춰 구현하기로 한 기능을 개발하는 것더 좋은 코드를 고민하면서 코드의 품질을 개선하는 것개발자는 '프로그래밍' 이라는 도구를 통해 주어진 문제를 해결하는 존재다.
여기서 중요한 것은, 어떠한 문제든 나에게 책임이 주어졌을 때 그것을 해결 해야한다는 것이다.어떤 문제는 매우 사소할 수 있다.
하지만 간혹, 어떤 문제는 잘 안풀리고 힘들고 어려울 수 있다.😵‍💫
개발자는 그런 문제를 해결하기 위해 코드와 씨름한다.퇴근 후 피곤한 몸을 이끌고 학원에가서 열심히 프론트엔드 과정 수업을 들었다.
분명 피곤할텐데, 몸이 힘들텐데, 이해가 되지 않거나 안풀리는 것이 있으면 새벽내내 코드와 씨름했다.어느날 와이프에게 새벽에 전화가 왔다.
나는 그날 회식이 좀 늦게 끝나서 집에 들어가는 길이었다.
자바스크립트 알고리즘에 관한 내용이었는데 이해가 잘 안된다고 헬프를 요청했다.
새벽까지도 코딩공부를 하는 와이프 (그 당시는 여자친구) 의 모습이 대견했다.
나도 아직 햇병아리 1년차 개발자였지만 내가 아는 선에서 최대한 설명했던 기억이 난다.본인이 해결해야 한다고 생각하는 것은 '사냥개' 처럼 끝까지 물고 해결하는 것.
내가 와이프를 통해 느꼈던 '어떤 사람이 개발자를 해야하는 걸까' 에 대한 첫번째 대답이었다.평생 기술적 겸손함을 가지고 공부하기와이프가 개발자로서의 첫 취업을 준비하면서 기술면접을 준비할 때였다.
개념 하나를 확실하게 이해하기 위해서 구글링과 유튜브, 책들을 정말 많이 찾아봤다.나는 이 정도면 충분히 답할 수 있을 것 같다고 이야기 했지만,
와이프의 대답은 습관적으로 같았다.👩🏻‍💻 ""아직 내가 잘 모르는 것 같아.""처음에는 와이프가 이런 말을 할 때마다 답답하기도 했다.
내가 보기에는 충분한데 너무 두려움이 많아 보였다.하지만, 와이프의 겸손함은 항상 더 나은 다음을 위해 꼭 필요한 것이었다.
잘 모른다고 생각하기 때문에 한번 더 두드려보고 공부한다.
이렇게 공부한 지식은 잘 잊어버리지 않는다.개발자는 그런 자세를 평생 가져야 한다고 생각한다.
기술적인 겸손함을 잊게 된다면, 게으르게 되고 공부를 더디하게 된다.
내가 존경하는 갓영한 선생님께서도 항상 강조하시는 것이 '기술적 겸손함'이다.무언가를 만들어 내는 것을 좋아하는 사람와이프는 상상력이 참 많은 사람이다.
재밌는 것들을 기획하고 상상하기를 좋아하는데, 이제는 코딩으로 그걸 실현까지 한다.🫢몇가지 와이프가 재미있게 혼자 만들어본 프로젝트를 소개한다.무덤덤한 대답하는 남편을 위한 플러팅 프로그램https://github.com/Anne-Hyeyeon/AImingmingReadme 에 나오는 '밍밍이'는 나를 말한다.프로그래밍을 처음 공부할 때 만든것이라서 코드는 매우 단순하면서도 쉽다. 하지만 아이디어가 너무 재미있다. ㅋㅋ이 고양이를 보신적 있습니까?https://github.com/Anne-Hyeyeon/this-cat-project키우는 고양이를 자랑하고 싶은 사람들을 위한 서비스다. (물론 고양이가 아니어도 된다.)약간 병ㅋ맛 감성을 유지하는 와이프의 상상력이 재미있다 ㅋㅋ..코딩 타로점 (Readme)https://github.com/Anne-Hyeyeon/Anne-Hyeyeon와이프의 깃헙 메인에 걸려있다. 이거보고 진짜 신박하다고 생각했다 ㅋㅋ..무언가 만드는 것을 좋아하면 개발자가 천직같다.
와이프는 상상력이 정말 좋은 사람인데, 그 상상력을 코딩으로 실현까지 가능하게 되어 신난다고 한다.🍅 본론 2. 개발자 부부의 삶은 어떠한가?프로젝트 하겠네?우리가 개발자 부부라고 하면 가장 먼저 나오는 반응이다.
심지어 나는 백엔드, 와이프는 프론트라고 하면 백퍼다 ㅋㅋ..놀랍게도 아직 우리는 어떠한 프로젝트도 계획하고 있지 않다.
(사실, 몇가지 이야기는 해봤지만 아직 정말 이야기만 한 수준이다. ㅋㅋ)아마.. 언젠가는 하지 않을까?개발자는 어쩔 수 없이 티가 난다.개발자들끼리 모여서 이야기를 나눴던 기억을 떠올려보자.
분명 다른 주제로 시작했는데, 결국에는 기술 이야기로 빠지지 않는가? 🤔개발자 부부도 그렇다.
우리는 참 대화하기를 좋아하고, 서로 생각을 나누는 것을 좋아한다.주말에는 술 한잔 🍺 하면서 인생에 대해 이야기도 많이 한다.
그런데, 와이프가 개발자가 되고나서는 그 인생 이야기에 개발이 묻어있다. 👨🏻‍💻👩🏻‍💻
너무나 자연스럽게 개발과 기술에 대한 이야기를 하게 된다.""와이프가 개발자가 아니었으면 너 이혼당했을거야.""내 친구가 나한테 한 말이다.
그 이유는 내 하루 루틴을 보면 알 것이다.
나의 평일 하루 루틴은 아래와 같다. 👨🏻‍💻나의 하루 루틴 
출근 - 열심히 코딩 - 퇴근 - 운동 - 개발공부 - 와이프와 기도 - 취침 신혼이라면 퇴근 후 도란도란 데이트도 하고 이야기도 하고 서로 시간을 보내는것에 가장 큰 시간을 쓸 것이다.나는 퇴근 후 가장 많이 시간을 쏟는 것은 개발공부하는 시간이다.
해도해도 끝이 없는 개발 공부 .. 📖만약 와이프가 개발자가 아니었다면 나를 이해하지 못했을 것이다.
아마 정말 이혼당했을지도..?와이프가 개발자가 되기 전에는 내가 퇴근하고 공부하는 것을 이해 못했다.
주말에 장애가 나서 회사 메신저를 계속 집중해서 보거나 급하게 코딩을 해야할 때 화도 냈었다.
신혼인데 본인이랑 놀기보다 계속 컴퓨터 앞에서 공부만 하는 로봇같은 남편이라니..
이혼 당해도 할말 없었을 것 같다. 🙄그러나, 와이프가 개발자가 되고 나서는 달라졌다.
퇴근하고 공부하는 것을 당연하게 여기고,
회사 코드에 문제가 생겼을 때 어떤 상황에서도 먼저 반응하는 것을 당연하게 생각한다.와이프가 쓴 와이프 블로그 글에 더 재미있게 나와있으니 관심있으신 분은 👉🏻 클릭🍉 본론 3. 하고싶은 것부부 개발자 vlog 를 하는 건 어떨까?둘다 약간의 관종끼를 가지고 있다. ㅎ..
언젠가는 둘의 이야기를 담은 vlog 를 하지 않을까 싶다.아직은 둘다 기술적인 경험과 경력을 쌓아야 하기 때문에 기술 이야기를 하기보다는,
부부 개발자가 집에서는 어떻게 살아가는지 일상을 공유하는 이야기를 만들면 어떨까 한다.그래도 프로젝트 하나는 해보자.백엔드와 프론트엔드가 한 집에서 살고있다.
API 로 아마 무진장 티키타카가 오고 가겠으나, 프로젝트를 하나 같이하면 재미있을 것 같다.여러가지 재미있는 상상은 하고 있으나, 아직 언제 실행될지는 모르겠다.
하지만 언젠가는 프로젝트를 꼭 할 것이다.책을 '더' 내보자.사실, 이미 우리는 책을 한권 냈다.
인쇄되어 서점에서 찾을 수는 없지만, '크몽' 이라는 플랫폼에서 전자책을 하나 썼다.제목은 '비전공자가 직장을 그만두지 않고 개발자로 이직하는 법' (클릭하면 책 링크로 이동한다)책의 내용은 말 그대로 비전공자가 직장을 그만두지 않고 개발자로 이직을 한 노하우를 깊고 찐하게 써놓은 책이다.
와이프가 개발자로 전향을 하면서 담은 모든 생각과 노하우를 숨김없이 썼다.
나는 백엔드 파트와 중간중간에 살짝 발을 담궜다 🫢책을 낸지는 벌써 반년이 지났다.
처음 와이프가 책을 쓰기로 하고, 나도 서포트를 하면서 이게 정말 사람들이 필요로 할지 긴가민가 했었다. 하지만, 생각보다 꾸준하게 사람들이 이 책을 구매했고, 도움이 되었다는 평가도 꽤나 많이 받았다.🤔
수익을 떠나서, 우리의 작은 경험이 사람들에게 도움이 된다는 것이 신기했다.
세상에 영향력을 끼칠 수 있다는 것이 참 감사했다.아마, 앞으로 이런 책들을 함께 써나갈 예정이다.🙏🏻 결론서로가 같은 필드에서 같은 곳을 바라보며 살아간다는 것은 참 복받은 일이다.부족하지만 우리가 경험하고 얻은 것들을 최대한 나누며 살아가는 그런 개발자 부부가 되길 소망한다.와이프와 항상 자기 전 기도하면서 그런 이야기를 한다.우리가 책상에 앉아서 작성하는 이 코드들이 세상을 조금 더 이롭고 아름답게 만들 수 있도록 열심히 노력하자고.따뜻한 기술을 세상을 조금 더 아름답게 바꿀 수 있는다고 믿는다.그리고, 우리 부부가 앞으로 많은 개발자들과 함께 그런 꿈을 꾸며 나아가길 소망해본다.좋아요 백개 누르고 싶습니다. 두분 모두 응원합니다!와 너무 대단하시네요 ...!!진짜 너무 잘 읽었고 좋은 글 이었습니다.
유익한 포스팅이었습니다
감사합니다저희 부부 이야기 처럼 재밌게 읽었습니다.두분 다 멋있으십니다...개발자 애인...저도 언젠간 개발자 애인을 얻고 싶네요ㅋㅋㅋ하루의 마무리로 이 글을 읽게 되었습니다 ㅎ 뭔가 다정하실 것 같은 두 분의 개발스토리 잘 보고갑니다.개발자 3년차인데, 책 내용이 도움이 될까요?프론트와 백.. 막강하네요 창과방패합치면 풀스텍이시네와 예전에 문구가 좋아서(기록은 기억은 이긴다) 기억에 남았던 벨로그인데 헤요미님 남편이셨군요..!ㅋㅋㅋㅋ두분 결이 같은가봐요 블로그 기운이 좋으심(?) 좋은 글 잘 보고 갑니다 ㅎㅎ퇴근 후 학원 + 과제라니 .. 진짜 대단하신 것 같아요",https://velog.io/@joshuara7235/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%B6%80%EB%B6%80%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%8B%B6%EC%96%B4%EC%84%9C-%EC%97%AC%EC%9E%90%EC%B9%9C%EA%B5%AC%EB%A5%BC-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%A7%8C%EB%93%A0-SSul-%ED%91%BC%EB%8B%A4
